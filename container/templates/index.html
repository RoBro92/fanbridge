<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="csrf-token" content="{{ csrf_token }}">
  <title>FanBridge</title>
  <!-- FanBridge UI: status, configuration, and modals; minimal client-side JS for polling -->
  <style>
    /* Theme variables */
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
    :root { --bg:#ffffff; --fg:#111827; --muted:#6b7280; --border:#e5e7eb; --thbg:#f6f8fa; --pillbg:#fafafa; --cardbg:#ffffff; }
    body.dark { --bg:#0f172a; --fg:#e5e7eb; --muted:#94a3b8; --border:#334155; --thbg:#111827; --pillbg:#1f2937; --cardbg:#0b1220; }
    body { background: var(--bg); color: var(--fg); }
    .muted { color: var(--muted); }
    table, th, td { border-color: var(--border); }
    th { background: var(--thbg); }
    .pill { border:1px solid var(--border); border-radius:999px; padding:3px 10px; background:var(--pillbg); font-size: 12px; color: var(--fg); }
    button { padding:6px 10px; border:1px solid var(--border); background:var(--pillbg); border-radius:6px; cursor:pointer; color: var(--fg); }
    button:hover { filter: brightness(1.05); }
    a { color: inherit; text-decoration: underline; }
    h1 { margin: 0 0 8px; }
    .meta { color: #666; margin-bottom: 16px; }

    table { border-collapse: collapse; width: 100%; max-width: 905px; }
    th, td { border: 1px solid; padding: 8px 10px; text-align: left; }

    /* State colours */
    .ok   { color: #0a7;   font-weight: 600; }
    .warn { color: #d97706; font-weight: 600; }
    .crit { color: #d32;   font-weight: 700; }

    .flex { display:flex; gap:12px; align-items:center; flex-wrap: wrap; }
    .pill.warn, .pill.error { 
      font-weight: 700;
      border-width: 2px;
    }
    .pill.warn  { border-color:#f59e0b; background:#fff7ed; color:#92400e; }
    .pill.error { border-color:#ef4444; background:#fef2f2; color:#991b1b; }
    .warnmsg { color:#b45309; margin:6px 0 0; }
    .errmsg  { color:#991b1b; margin:6px 0 0; }
    .pill.clickable { cursor: pointer; position: relative; }
    .pill.clickable::after { content: " ✎"; opacity: .75; }
    .pill.clickable:hover { filter: brightness(1.06); }
    .small { font-size: 12px; }
    .right { float:right; }
    .footer { margin-top: 16px; }
    code { background:#f6f8fa; padding:2px 6px; border-radius:4px; }

    /* Banners and toasts */
    .banner { display:none; border:1px solid var(--border); border-radius:8px; padding:10px 12px; margin:12px 0; background: var(--pillbg); }
    .banner.warn  { border-color:#f59e0b; background:#fff7ed; color:#92400e; }
    .banner.error { border-color:#ef4444; background:#fef2f2; color:#991b1b; }

    .toast-container { position: fixed; right: 16px; bottom: 16px; display:flex; flex-direction:column; gap:8px; z-index: 2000; }
    .toast { padding:10px 12px; border-radius:8px; border:1px solid var(--border); background: var(--cardbg); box-shadow: 0 6px 18px rgba(0,0,0,.2); min-width: 220px; }
    .toast.info  { border-color:#93c5fd; background:#eff6ff; color:#1e3a8a; }
    .toast.ok    { border-color:#86efac; background:#ecfdf5; color:#065f46; }
    .toast.warn  { border-color:#f59e0b; background:#fff7ed; color:#92400e; }
    .toast.error { border-color:#ef4444; background:#fef2f2; color:#991b1b; }

    .panel { border:1px solid var(--border); border-radius:8px; padding:12px; background: var(--cardbg); max-width: 880px; margin-top:16px; }
    .panel h2 { margin:0 0 8px; font-size:16px; }
    .chk { display:inline-flex; align-items:center; gap:6px; margin:6px 12px 6px 0; }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:6px 12px; }
    .inputs { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    input[type="number"] { width: 72px; padding:4px 6px; }

    /* Table column widths */
    th.type,  td.type  { text-align: center; width: 90px; }
    th.state, td.state { text-align: center; width: 90px; }
    th.temp,  td.temp  { text-align: center; width: 110px; }
    th.inc,   td.inc   { text-align: center; width: 90px; }
    td.inc { text-align:center; }
    input.incl { transform: scale(1.3); accent-color: #16a34a; }

    .grid#curveH_th, .grid#curveH_pw, .grid#curveS_th, .grid#curveS_pw { grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); }
    .grid#curveH_th input, .grid#curveH_pw input, .grid#curveS_th input, .grid#curveS_pw input { width: 64px; }
    .rowlabel { min-width: 110px; }

    /* Form controls */
    input, select {
      background: var(--cardbg);
      color: var(--fg);
      border: 1px solid var(--border);
      color-scheme: light;
    }
    input[type="password"] { width: 100%; padding:6px 8px; }
    body.dark input, body.dark select { color-scheme: dark; }

    /* Dark mode number inputs */
    body.dark input[type="number"]::-webkit-outer-spin-button,
    body.dark input[type="number"]::-webkit-inner-spin-button {
      opacity: 1 !important;
      filter: invert(1) brightness(1.8) contrast(2) drop-shadow(0 0 0.5px #000);
    }

    input[disabled], select[disabled] { opacity: .75; }

    /* Ensure temp cells don't inherit odd backgrounds in dark mode */
    td.temp.ok, td.temp.warn, td.temp.crit { background: transparent !important; text-shadow: none; }

    /* Unraid-style gradient brand title */
    .brand {
      background: linear-gradient(90deg, #e53935 0%, #ff7043 35%, #ff9800 100%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      font-weight: 800;
    }
    /* Compact dropdown menu pill */
    .menu { position: relative; display:inline-block; }
    .menu-list {
      position: absolute; right: 0; top: calc(100% + 6px);
      background: var(--cardbg); color: var(--fg);
      border: 1px solid var(--border); border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      min-width: 180px; padding: 6px;
      z-index: 1500;
    }
    .menu-item {
      display: block; width: 100%; text-align: left;
      padding: 8px 10px; border: none; background: transparent;
      border-radius: 6px; cursor: pointer; color: var(--fg);
    }
    .menu-item:hover { background: var(--pillbg); }
    /* Prevent header pills from overflowing too far; allow wrap neatly */
    .meta { color: #666; margin-bottom: 16px; max-width: 905px; }
  </style>
</head>
<body data-poll="{{ poll_s|int }}" data-version="{{ version or '—' }}">
  <h1 class="brand">FanBridge for Unraid</h1>

  <div class="meta flex">
    <span id="ver"   class="pill">version: {{ version or "—" }}</span>
    <span id="serialpill" class="pill" title="USB serial connection to Arduino / RP2040">serial: …</span>
    <button id="pollbtn" class="pill clickable" type="button" title="Click to change the refresh interval (3–60 seconds)">refresh: …</button>
    <span id="mtime" class="pill">disks.ini: …</span>
    <span id="updated" class="pill" title="">updated: …</span>
    <div class="menu">
      <button id="menuBtn" class="pill" type="button" aria-haspopup="true" aria-expanded="false">Menu ▾</button>
      <div id="menuList" class="menu-list" role="menu" aria-labelledby="menuBtn" style="display:none;">
        <button id="menuTheme"  class="menu-item" role="menuitem">Theme: …</button>
        <button id="menuPw"     class="menu-item" role="menuitem">Change password</button>
        <button id="menuLogout" class="menu-item" role="menuitem">Logout</button>
      </div>
    </div>
  </div>

  <div id="statusBanner" class="banner warn"></div>

  <table id="tbl">
    <thead>
      <tr>
        <th>Device</th>
        <th class="type">Type</th>
        <th class="state">State</th>
        <th class="temp">Temp (°C)</th>
        <th class="inc">Included</th>
      </tr>
    </thead>
    <tbody id="rows">
      <tr><td colspan="5" class="muted">Loading…</td></tr>
    </tbody>
    <tfoot>
      <tr>
        <th colspan="5">
          HDD avg/min/max: <span id="hddstats" class="small muted">—</span> &nbsp; | &nbsp;
          SSD avg/min/max: <span id="ssdstats" class="small muted">—</span> &nbsp; | &nbsp;
          Recommended PWM: <strong id="pwm">—</strong>
        </th>
      </tr>
    </tfoot>
  </table>

  <div class="panel">
    <div class="config-header" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
      <h1 style="margin:0;">Configuration</h1>
      <div class="config-actions" style="display:flex; align-items:center; gap:10px;">
        <div id="configFlags" style="display:flex; gap:8px; align-items:center;">
          <span id="dirtyFlag" class="pill warn" style="display:none;">Unsaved changes</span>
          <span id="valFlag" class="pill error" style="display:none;">Fix validation errors</span>
        </div>
        <button id="resetDefaults" class="pill" type="button" title="Reset overrides and fan curves to defaults">Reset to defaults</button>
  </div>
</div>

  <!-- Modal: Refresh Interval -->
  <div id="pollModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.45); align-items:center; justify-content:center; z-index:1000;">
    <div style="background: var(--cardbg); color: var(--fg); border:1px solid var(--border); border-radius:10px; padding:16px; width: min(420px, 92vw); box-shadow: 0 10px 30px rgba(0,0,0,.3);">
      <h3 style="margin:0 0 10px;">Set refresh interval</h3>
      <p class="small" style="margin:0 0 10px; color:var(--muted);">
        Choose how often the page polls Unraid for drive temperatures (3–60 seconds).
      </p>
      <div class="inputs" style="align-items:center;">
        <label for="poll_input">Seconds</label>
        <input type="number" id="poll_input" min="3" max="60" step="1" value="7" style="width:96px;">
      </div>
      <div id="poll_error" class="small" style="margin-top:8px; color:#b91c1c;"></div>
      <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:14px;">
        <button id="poll_cancel">Cancel</button>
        <button id="poll_save">Save</button>
      </div>
    </div>
  </div>

    <h2>Single Drive Max Overrides</h2>
    <div class="inputs">
      <label>HDD  (°C): <input type="number" id="hddovr" min="30" max="70" step="1"></label>
      <label>SSD  (°C): <input type="number" id="ssdovr" min="40" max="90" step="1"></label>
      <button id="savebtn">Save</button>
      <button id="discardbtn" style="display:none;">Discard</button>
    </div>

    <h2 style="margin-bottom:8px;">Fan curves</h2>
    <div class="small muted" style="margin-bottom:10px;">
      Set the fan curve from temperature to PWM. Left to right = increasing temperature.
    </div>

    <h2 style="margin:6px 0 6px;">HDD fan curve</h2>
    <div class="inputs" style="align-items:flex-start;">
      <div class="rowlabel small muted" style="width:130px;">Thresholds (°C)</div>
      <div class="grid" id="curveH_th"></div>
    </div>
    <div class="inputs" style="align-items:flex-start; margin-top:6px;">
      <div class="rowlabel small muted" style="width:130px;">PWM (%)</div>
      <div class="grid" id="curveH_pw"></div>
      <div id="curveH_warn" class="warnmsg small" style="display:none;"></div>
    </div>

    <h2 style="margin:12px 0 6px;">SSD fan curve</h2>
    <div class="inputs" style="align-items:flex-start;">
      <div class="rowlabel small muted" style="width:130px;">Thresholds (°C)</div>
      <div class="grid" id="curveS_th"></div>
    </div>
    <div class="inputs" style="align-items:flex-start; margin-top:6px;">
      <div class="rowlabel small muted" style="width:130px;">PWM (%)</div>
      <div class="grid" id="curveS_pw"></div>
      <div id="curveS_warn" class="warnmsg small" style="display:none;"></div>
    </div>

    <div class="inputs" style="margin-top:10px;">
      <button id="savecurves" disabled>Save</button>
      <button id="discardcurves" style="display:none;">Discard</button>
    </div>
  </div>

  <div class="footer small muted">
    <a href="/api/status">API</a> &nbsp;|&nbsp; <a href="/health">Health</a>
  </div>

  <!-- Modal: Change Password -->
  <div id="pwModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.45); align-items:center; justify-content:center; z-index:1000;">
    <div style="background: var(--cardbg); color: var(--fg); border:1px solid var(--border); border-radius:10px; padding:16px; width: min(420px, 92vw); box-shadow: 0 10px 30px rgba(0,0,0,.3);">
      <h3 style="margin:0 0 10px;">Change password</h3>
      <div class="inputs" style="flex-direction:column; align-items:stretch; gap:10px;">
        <label>Current password
          <input type="password" id="pw_current" autocomplete="current-password">
        </label>
        <label>New password
          <input type="password" id="pw_new" autocomplete="new-password">
        </label>
        <label>Confirm new password
          <input type="password" id="pw_confirm" autocomplete="new-password">
        </label>
      </div>
      <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:14px;">
        <button id="pw_cancel">Cancel</button>
        <button id="pw_save">Save</button>
      </div>
      <div id="pw_error" class="small muted" style="margin-top:8px; color:#b91c1c;"></div>
    </div>
  </div>

  <!-- Modal: Reset to Defaults -->
  <div id="resetModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.45); align-items:center; justify-content:center; z-index:1000;">
    <div style="background: var(--cardbg); color: var(--fg); border:1px solid var(--border); border-radius:10px; padding:16px; width: min(420px, 92vw); box-shadow: 0 10px 30px rgba(0,0,0,.3);">
      <h3 style="margin:0 0 10px;">Reset to defaults</h3>
      <p class="small" style="margin:0 0 10px; color:var(--muted);">
        This will restore the single‑drive temperature overrides and both fan curves to their factory defaults.
      </p>
      <p style="margin:0 0 12px; font-weight:600;">Are you sure you want to proceed?</p>
      <div style="display:flex; gap:10px; justify-content:flex-end;">
        <button id="reset_cancel">Cancel</button>
        <button id="reset_confirm">Reset</button>
      </div>
      <div id="reset_error" class="small" style="margin-top:8px; color:#b91c1c;"></div>
    </div>
  </div>


  <script>
    let pollSeconds = parseInt(document.body.dataset.poll || '7', 10);
    let pollTimer = null;
    let pollTimerSerial = null;
    function startPolling(){
      if (pollTimer) clearInterval(pollTimer);
      if (pollTimerSerial) clearInterval(pollTimerSerial);
      const ms = Math.max(3, Math.min(60, pollSeconds))*1000;
      pollTimer = setInterval(refresh, ms);
      pollTimerSerial = setInterval(refreshSerial, ms);
      const pb = document.getElementById('pollbtn');
      if (pb) pb.textContent = `refresh: every ${Math.max(3, Math.min(60, pollSeconds))}s`;
      if (pb) pb.title = 'Click to change the refresh interval (3–60 seconds)';
    }
    // Serial status updater
    async function refreshSerial(){
      const el = document.getElementById('serialpill');
      if (!el) return;
      try {
        const r = await fetch('/api/serial/status', { cache: 'no-store' });
        const j = await r.json();
        if (j.connected) {
          el.textContent = 'serial: connected';
          el.title = (j.preferred ? `Using ${j.preferred}` : (j.ports && j.ports[0] ? `Using ${j.ports[0]}` : 'connected'));
          el.classList.remove('error','warn');
        } else {
          const hint = (j.ports && j.ports.length) ? 'not opened (permission?)' : 'not found';
          el.textContent = 'serial: ' + hint;
          el.title = (j.ports && j.ports.length)
            ? `Found: ${j.ports.join(', ')}. Map the correct device in the Unraid template (Add another Path, Port, Variable, Label or Device ➜ Device).`
            : 'No serial devices visible in container. Map /dev/ttyACM* or /dev/ttyUSB* via the template.';
          el.classList.remove('error','warn');
          el.classList.add('warn');
        }
      } catch (e) {
        el.textContent = 'serial: error';
        el.title = 'Failed to query /api/serial/status';
        el.classList.remove('warn');
        el.classList.add('error');
      }
    }
    const fmt = (v) => (v === null || v === undefined) ? "—" : v;
    const CSRF = document.querySelector('meta[name="csrf-token"]').content;

    // Status formatting helpers
    function formatAge(ms){
      if (ms <= 0 || isNaN(ms)) return 'n/a';
      const s = Math.floor(ms/1000);
      const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), ss = s%60;
      if (h>0) return `${h}:${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')} ago`;
      return `${m}:${String(ss).padStart(2,'0')} ago`;
    }
    function setBanner(msg, type='warn'){
      const b = document.getElementById('statusBanner');
      if (!b) return;
      if (!msg) { b.style.display='none'; b.textContent=''; b.classList.remove('warn','error'); return; }
      b.textContent = msg;
      b.classList.remove('warn','error');
      b.classList.add(type);
      b.style.display='block';
    }
    function showToast(msg, type='ok', timeoutMs=3000){
      const host = document.getElementById('toastHost');
      if (!host) return;
      const el = document.createElement('div');
      el.className = `toast ${type}`;
      el.textContent = msg;
      host.appendChild(el);
      setTimeout(()=>{ el.style.opacity='0'; el.style.transition='opacity .25s'; setTimeout(()=> el.remove(), 260); }, timeoutMs);
    }

    // dynamic colour class based on per-type override thresholds
    let OVERRIDE_HDD = 45;
    let OVERRIDE_SSD = 60;
    const WARN_DELTA = 5; // orange when within 5°C of override
    let HTH = [], HPW = [], STH = [], SPW = [];
    let DIRTY_OVR = false;   // overrides edited but not saved
    let DIRTY_CURVES = false; // fan curves edited but not saved

    function setDirty(which, v=true){
      if(which === 'ovr') DIRTY_OVR = v; else if(which === 'curves') DIRTY_CURVES = v;
      const any = DIRTY_OVR || DIRTY_CURVES;
      document.getElementById('dirtyFlag').style.display = any ? '' : 'none';
      document.getElementById('discardbtn').style.display = DIRTY_OVR ? '' : 'none';
      document.getElementById('discardcurves').style.display = DIRTY_CURVES ? '' : 'none';
    }
    
    // ---- Curve validation helpers ----
function isStrictlyIncreasing(arr){
  for (let i=1;i<arr.length;i++){ if (!(arr[i] > arr[i-1])) return false; }
  return true;
}
function isNonDecreasing01(arr){
  for (let i=0;i<arr.length;i++){
    const v = arr[i];
    if (isNaN(v) || v < 0 || v > 100) return false;
    if (i>0 && v < arr[i-1]) return false;
  }
  return true;
}
function validatePair(th, pw){
  if (th.length !== pw.length) return { ok:false, msg:`Lengths differ (thresholds=${th.length}, pwm=${pw.length}).` };
  if (th.length === 0) return { ok:false, msg:'Add at least one step.' };
  if (!isStrictlyIncreasing(th)) return { ok:false, msg:'Thresholds must increase (e.g. 25, 28, 32...).' };
  if (!isNonDecreasing01(pw)) return { ok:false, msg:'PWM must be 0–100 and non-decreasing (e.g. 0, 10, 10, 20...).' };
  return { ok:true, msg:'' };
}
function gatherCurveInputs(containerId){
  return Array.from(document.querySelectorAll(`#${containerId} input`)).map(i=>parseInt(i.value||'0',10));
}
function showWarn(id, msg){
  const el = document.getElementById(id);
  if (!el) return;
  if (msg){ el.textContent = msg; el.style.display=''; }
  else { el.textContent=''; el.style.display='none'; }
}
function applyValidation(){
  // read current editors (fall back to arrays if inputs not yet built)
  const hth = document.querySelectorAll('#curveH_th input').length ? gatherCurveInputs('curveH_th') : HTH.slice();
  const hpw = document.querySelectorAll('#curveH_pw input').length ? gatherCurveInputs('curveH_pw') : HPW.slice();
  const sth = document.querySelectorAll('#curveS_th input').length ? gatherCurveInputs('curveS_th') : STH.slice();
  const spw = document.querySelectorAll('#curveS_pw input').length ? gatherCurveInputs('curveS_pw') : SPW.slice();
  const vh = validatePair(hth, hpw);
  const vs = validatePair(sth, spw);
  showWarn('curveH_warn', vh.ok ? '' : vh.msg);
  showWarn('curveS_warn', vs.ok ? '' : vs.msg);
  const saveBtn = document.getElementById('savecurves');
  const valFlag = document.getElementById('valFlag');
  const ok = vh.ok && vs.ok;
  if (saveBtn) saveBtn.disabled = !ok;
  if (valFlag) valFlag.style.display = ok ? 'none' : '';
}

    const clsForTemp = (t, type) => {
      if (t === null || t === undefined) return "muted";
      const thr = (String(type).toUpperCase() === 'SSD') ? OVERRIDE_SSD : OVERRIDE_HDD;
      if (t >= thr) return "crit";
      if (t >= (thr - WARN_DELTA)) return "warn";
      return "ok";
    };

    // --- fetch with timeout helper (to avoid hanging connections) ---
    async function fetchWithTimeout(url, options = {}, timeoutMs = 12000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeoutMs);
      try {
        const resp = await fetch(url, { ...options, signal: controller.signal });
        return resp;
      } finally {
        clearTimeout(id);
      }
    }

    async function refresh() {
      try {
        // extend timeout to tolerate slower disks.ini reads / network hiccups
        const r = await fetchWithTimeout('/api/status', { cache: 'no-store' }, Math.max(10000, Math.min(25000, (pollSeconds || 7) * 2000)));
        const j = await r.json();

        const VERSION_FALLBACK = document.body.dataset.version || '—';
        document.getElementById('ver').textContent = 'version: ' + (j.version || VERSION_FALLBACK);
        document.getElementById('pwm').textContent = (j.recommended_pwm ?? '—') + '%';

        const now = new Date();
        const updEl = document.getElementById('updated');
        updEl.textContent = 'updated: ' + now.toLocaleTimeString();
        updEl.title = 'FanBridge last fetched /api/status at: ' + now.toLocaleString();

        // disks.ini mtime pill + banner logic
        const mtEl = document.getElementById('mtime');
        let mtLabel = 'n/a';
        let bannerMsg = '';
        if (j.disks_ini_mtime){
          const wrote = j.disks_ini_mtime * 1000;
          mtLabel = formatAge(Date.now() - wrote);
          mtEl.title = 'Unraid wrote /var/local/emhttp/disks.ini at: ' + new Date(wrote).toLocaleString();
          if ((Date.now() - wrote) > 60000) bannerMsg = 'Warning: /unraid/disks.ini appears stale (older than 60s).';
        } else {
          mtEl.title = 'disks.ini timestamp not available';
          bannerMsg = 'Could not read /unraid/disks.ini (is the path mapped read-only to the container?)';
        }
        mtEl.textContent = 'disks.ini: ' + mtLabel;
        setBanner(bannerMsg || '', bannerMsg ? 'warn' : 'warn');

        // sync dynamic thresholds from server so colours reflect current settings
        if (typeof j.override_hdd_c === 'number') OVERRIDE_HDD = j.override_hdd_c;
        if (typeof j.override_ssd_c === 'number') OVERRIDE_SSD = j.override_ssd_c;
        if (Array.isArray(j.hdd_thresholds)) HTH = j.hdd_thresholds.slice();
        if (Array.isArray(j.hdd_pwm)) HPW = j.hdd_pwm.slice();
        if (Array.isArray(j.ssd_thresholds)) STH = j.ssd_thresholds.slice();
        if (Array.isArray(j.ssd_pwm)) SPW = j.ssd_pwm.slice();

        const rows = document.getElementById('rows');
        rows.innerHTML = '';
        if (!j.drives || j.drives.length === 0) {
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 5;
          td.className = 'muted';
          td.textContent = 'No drives detected.';
          tr.appendChild(td);
          rows.appendChild(tr);
        }
        (j.drives || []).forEach(d => {
          const tr = document.createElement('tr');
          const tdDev = document.createElement('td'); tdDev.textContent = d.dev ? (d.slot ? (d.dev + ' (' + d.slot + ')') : d.dev) : '—';
          const tdType = document.createElement('td'); tdType.textContent = d.type || '—'; tdType.className = 'type';
          const tdState = document.createElement('td'); tdState.textContent = d.state || '—'; tdState.className = 'state';
          const tdTemp = document.createElement('td'); tdTemp.textContent = fmt(d.temp); tdTemp.className = 'temp ' + clsForTemp(d.temp, d.type);
          const tdInc = document.createElement('td'); tdInc.className = 'inc';

          const cbInc = document.createElement('input');
          cbInc.type = 'checkbox';
          cbInc.className = 'incl';
          cbInc.checked = !d.excluded; // checked means INCLUDED in calculations
          cbInc.onchange = async (e) => {
            try {
              await fetch('/api/exclude', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': CSRF },
                body: JSON.stringify({ dev: d.dev, excluded: !e.target.checked })
              });
            } catch (err) { console.error(err); }
          };
          tdInc.appendChild(cbInc);

          tr.append(tdDev, tdType, tdState, tdTemp, tdInc);
          rows.appendChild(tr);
        });

        const hs = j.hdd || {}, ss = j.ssd || {};
        document.getElementById('hddstats').textContent = (fmt(hs.avg) + ' / ' + fmt(hs.min) + ' / ' + fmt(hs.max) + '  (n=' + fmt(hs.count) + ')');
        document.getElementById('ssdstats').textContent = (fmt(ss.avg) + ' / ' + fmt(ss.min) + ' / ' + fmt(ss.max) + '  (n=' + fmt(ss.count) + ')');

        // populate override inputs only if not being edited (dirty)
        if (!DIRTY_OVR) {
          if (typeof j.override_hdd_c !== 'undefined') document.getElementById('hddovr').value = j.override_hdd_c;
          if (typeof j.override_ssd_c !== 'undefined') document.getElementById('ssdovr').value = j.override_ssd_c;
        }

        // populate fan curve editors (skip if user is editing to prevent overwrites)
        if (!DIRTY_CURVES) {
          const ch_th = document.getElementById('curveH_th'); ch_th.innerHTML='';
          const ch_pw = document.getElementById('curveH_pw'); ch_pw.innerHTML='';
          const cs_th = document.getElementById('curveS_th'); cs_th.innerHTML='';
          const cs_pw = document.getElementById('curveS_pw'); cs_pw.innerHTML='';

          const makeNum = (val)=>{ const i=document.createElement('input'); i.type='number'; i.min='0'; i.max='100'; i.step='1'; i.value = val; i.addEventListener('input', ()=> setDirty('curves', true)); return i; };

          const nH = Math.max(HTH.length, HPW.length) || 1;
          const nS = Math.max(STH.length, SPW.length) || 1;
          ch_th.style.gridTemplateColumns = `repeat(${nH}, minmax(70px, 1fr))`;
          ch_pw.style.gridTemplateColumns = `repeat(${nH}, minmax(70px, 1fr))`;
          cs_th.style.gridTemplateColumns = `repeat(${nS}, minmax(70px, 1fr))`;
          cs_pw.style.gridTemplateColumns = `repeat(${nS}, minmax(70px, 1fr))`;

          for (let i=0;i<nH;i++) { ch_th.appendChild(makeNum(HTH[i]!==undefined?HTH[i]:0)); ch_pw.appendChild(makeNum(HPW[i]!==undefined?HPW[i]:0)); }
          for (let i=0;i<nS;i++) { cs_th.appendChild(makeNum(STH[i]!==undefined?STH[i]:0)); cs_pw.appendChild(makeNum(SPW[i]!==undefined?SPW[i]:0)); }
          // validate after rebuilding editors
          document.querySelectorAll('#curveH_th input, #curveH_pw input, #curveS_th input, #curveS_pw input')
            .forEach(inp => inp.addEventListener('input', applyValidation));
          // Initial validation state
          applyValidation();
        }

        // If we successfully refreshed (i.e., no fetch error) and there is no stale warning, clear any error banner.
        const sb = document.getElementById('statusBanner');
        if (sb && sb.style.display === 'block' && !bannerMsg) {
          setBanner('');
        }
      } catch (e) {
        console.error(e);
        setBanner('Unable to fetch /api/status — check container is running and network is reachable.', 'error');
        if (e.name === 'AbortError') {
          console.warn('Status fetch aborted due to timeout.');
        }
      }
    }

    refresh();
    refreshSerial();
    startPolling();

    // --- Themed Refresh Interval Modal ---
    (function(){
      const btn = document.getElementById('pollbtn');
      const modal = document.getElementById('pollModal');
      const inp = document.getElementById('poll_input');
      const cancelBtn = document.getElementById('poll_cancel');
      const saveBtn = document.getElementById('poll_save');
      const err = document.getElementById('poll_error');

      function openModal(){
        if (!modal) return;
        if (err) err.textContent = '';
        if (inp) inp.value = String(Math.max(3, Math.min(60, pollSeconds || 7)));
        modal.style.display = 'flex';
        setTimeout(()=> inp && inp.focus(), 0);
      }
      function closeModal(){ if (modal) modal.style.display = 'none'; }

      if (btn) btn.addEventListener('click', openModal);
      if (cancelBtn) cancelBtn.addEventListener('click', closeModal);
      if (modal) modal.addEventListener('click', (ev)=>{ if (ev.target === modal) closeModal(); });

      async function savePoll(){
        if (!inp) return;
        if (err) err.textContent = '';
        let val = parseInt(inp.value, 10);
        if (isNaN(val)) { if (err) err.textContent = 'Please enter a number between 3 and 60.'; return; }
        if (val < 3) val = 3;
        if (val > 60) val = 60;

        try {
          // Update UI + timer
          pollSeconds = val;
          document.body.dataset.poll = String(val);
          startPolling();

          // Persist to server
          const r = await fetch('/api/settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': CSRF },
            body: JSON.stringify({ poll_interval_seconds: val })
          });
          if (!r.ok) {
            if (err) err.textContent = 'Failed to save. Please try again.';
            showToast('Failed to save refresh interval', 'error');
            return;
          }
          showToast(`Refresh set to ${val}s`, 'ok');
          closeModal();
        } catch(e){
          console.error(e);
          if (err) err.textContent = 'Unexpected error.';
          showToast('Error saving refresh interval', 'error');
        }
      }
      if (saveBtn) saveBtn.addEventListener('click', savePoll);
      if (inp) inp.addEventListener('keydown', (ev)=>{ if (ev.key === 'Enter') savePoll(); });
    })();

    // --- Dropdown Menu (Theme / Change password / Logout) ---
    (function(){
      const btn   = document.getElementById('menuBtn');
      const list  = document.getElementById('menuList');
      const mTheme  = document.getElementById('menuTheme');
      const mPw     = document.getElementById('menuPw');
      const mLogout = document.getElementById('menuLogout');

      function openMenu(){ if (list){ list.style.display='block'; btn.setAttribute('aria-expanded','true'); } }
      function closeMenu(){ if (list){ list.style.display='none'; btn.setAttribute('aria-expanded','false'); } }
      function toggleMenu(e){ e.stopPropagation(); if (!list) return;
        list.style.display = (list.style.display === 'block') ? 'none' : 'block';
        btn.setAttribute('aria-expanded', list.style.display === 'block' ? 'true' : 'false');
      }

      if (btn) btn.addEventListener('click', toggleMenu);
      // Close when clicking outside
      document.addEventListener('click', (ev)=> {
        if (!list || !btn) return;
        const within = btn.contains(ev.target) || list.contains(ev.target);
        if (!within) closeMenu();
      });

      // Theme toggle now lives in menu
      if (mTheme) mTheme.addEventListener('click', ()=> {
        const next = document.body.classList.contains('dark') ? 'light' : 'dark';
        applyTheme(next);
        // Update menu label
        mTheme.textContent = 'Theme: ' + (next === 'dark' ? 'Dark' : 'Light');
        closeMenu();
      });

      // Open Change Password modal
      if (mPw) mPw.addEventListener('click', ()=> {
        const btnOpen = document.getElementById('pwbtn');
        // For backward compatibility, call the modal opener directly:
        const modal = document.getElementById('pwModal');
        if (modal){
          // emulate previous openModal() logic
          const err = document.getElementById('pw_error');
          const inpCur = document.getElementById('pw_current');
          const inpNew = document.getElementById('pw_new');
          const inpConf= document.getElementById('pw_confirm');
          if (err) err.textContent = '';
          if (inpCur) inpCur.value = '';
          if (inpNew) inpNew.value = '';
          if (inpConf) inpConf.value= '';
          modal.style.display = 'flex';
          setTimeout(()=> inpCur && inpCur.focus(), 0);
        }
        closeMenu();
      });

      // Logout
      if (mLogout) mLogout.addEventListener('click', async ()=> {
        try {
          const r = await fetch('/logout', { method: 'POST', headers: { 'X-CSRF-Token': CSRF } });
          if (r.ok) location.reload(); else showToast('Logout failed', 'error');
        } catch(e){ console.error(e); showToast('Logout error', 'error'); }
        closeMenu();
      });

      // Initialize theme label once
      if (mTheme){
        mTheme.textContent = 'Theme: ' + (document.body.classList.contains('dark') ? 'Dark' : 'Light');
      }
    })();


    // ---- Change password modal ----
    (function () {
      const modal = document.getElementById('pwModal');
      const btnCancel = document.getElementById('pw_cancel');
      const btnSave = document.getElementById('pw_save');
      const inpCur = document.getElementById('pw_current');
      const inpNew = document.getElementById('pw_new');
      const inpConf = document.getElementById('pw_confirm');
      const err = document.getElementById('pw_error');

      function openModal() {
        if (!modal) return;
        err.textContent = '';
        inpCur.value = '';
        inpNew.value = '';
        inpConf.value = '';
        modal.style.display = 'flex';
        setTimeout(() => inpCur.focus(), 0);
      }
      function closeModal() {
        if (!modal) return;
        modal.style.display = 'none';
      }

      if (btnCancel) btnCancel.addEventListener('click', closeModal);

      if (btnSave) btnSave.addEventListener('click', async () => {
        err.textContent = '';
        const current = inpCur.value || '';
        const next = inpNew.value || '';
        const confirmPw = inpConf.value || '';
        if (!current || !next || !confirmPw) {
          err.textContent = 'Please fill in all fields.';
          return;
        }
        if (next !== confirmPw) {
          err.textContent = 'New passwords do not match.';
          return;
        }
        try {
          const r = await fetch('/api/change_password', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': CSRF },
            body: JSON.stringify({ current, new: next, confirm: confirmPw })
          });
          const j = await r.json().catch(() => ({}));
          if (!r.ok || !j.ok) {
            err.textContent = j.error || r.statusText || 'Failed to change password.';
            showToast('Failed to change password', 'error');
          } else {
            closeModal();
            showToast('Password updated', 'ok');
          }
        } catch (e) {
          console.error(e);
          err.textContent = 'Unexpected error.';
        }
      });

      // Close modal when clicking the overlay
      if (modal) {
        modal.addEventListener('click', (ev) => {
          if (ev.target === modal) closeModal();
        });
      }
    })();

    document.getElementById('hddovr').addEventListener('input', ()=> setDirty('ovr', true));
    document.getElementById('ssdovr').addEventListener('input', ()=> setDirty('ovr', true));

    document.getElementById('savebtn').addEventListener('click', async () => {
      const h = parseInt(document.getElementById('hddovr').value, 10);
      const s = parseInt(document.getElementById('ssdovr').value, 10);
      try {
        await fetch('/api/settings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': CSRF },
          body: JSON.stringify({
            single_override_hdd_c: isNaN(h) ? undefined : h,
            single_override_ssd_c: isNaN(s) ? undefined : s
          })
        });
        setDirty('ovr', false);
        showToast('Overrides saved', 'ok');
        refresh();
      } catch (err) {
        showToast('Failed to save overrides', 'error');
        console.error(err);
      }
    });

    document.getElementById('savecurves').addEventListener('click', async () => {
      const ch_th = document.getElementById('curveH_th').querySelectorAll('input');
      const ch_pw = document.getElementById('curveH_pw').querySelectorAll('input');
      const cs_th = document.getElementById('curveS_th').querySelectorAll('input');
      const cs_pw = document.getElementById('curveS_pw').querySelectorAll('input');
      const HTH2 = Array.from(ch_th).map(i => parseInt(i.value||'0',10));
      const HPW2 = Array.from(ch_pw).map(i => parseInt(i.value||'0',10));
      const STH2 = Array.from(cs_th).map(i => parseInt(i.value||'0',10));
      const SPW2 = Array.from(cs_pw).map(i => parseInt(i.value||'0',10));
      try {
        await fetch('/api/curves', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': CSRF },
          body: JSON.stringify({ hdd_thresholds: HTH2, hdd_pwm: HPW2, ssd_thresholds: STH2, ssd_pwm: SPW2 })
        });
        setDirty('curves', false);
        showToast('Fan curves saved', 'ok');
        refresh();
      } catch (err) {
        showToast('Failed to save fan curves', 'error');
        console.error(err);
      }
    });

    document.getElementById('discardbtn').addEventListener('click', ()=> { setDirty('ovr', false); refresh(); });
    document.getElementById('discardcurves').addEventListener('click', ()=> { setDirty('curves', false); refresh(); });

    // Reset to defaults (overrides + fan curves)
    (function(){
      const btn = document.getElementById('resetDefaults');
      const modal = document.getElementById('resetModal');
      const cancelBtn = document.getElementById('reset_cancel');
      const confirmBtn = document.getElementById('reset_confirm');
      const err = document.getElementById('reset_error');

      if (!btn || !modal) return;

      function openModal(){
        if (err) err.textContent = '';
        modal.style.display = 'flex';
      }
      function closeModal(){ modal.style.display = 'none'; }

      btn.addEventListener('click', openModal);
      if (cancelBtn) cancelBtn.addEventListener('click', closeModal);
      if (modal) modal.addEventListener('click', (ev)=>{ if (ev.target === modal) closeModal(); });

      if (confirmBtn) confirmBtn.addEventListener('click', async ()=>{
        if (err) err.textContent = '';
        try {
          const r = await fetch('/api/reset_defaults', { method: 'POST', headers: { 'X-CSRF-Token': CSRF } });
          const j = await r.json().catch(()=>({}));
          if (!r.ok || !j.ok) {
            if (err) err.textContent = j.error || 'Failed to reset.';
            showToast('Failed to reset defaults', 'error');
            return;
          }
          setDirty('ovr', false);
          setDirty('curves', false);
          closeModal();
          showToast('Restored defaults', 'ok');
          refresh();
        } catch (e) {
          console.error(e);
          if (err) err.textContent = 'Unexpected error while resetting.';
          showToast('Failed to reset defaults', 'error');
        }
      });
    })();

    // Theme toggle (light/dark)
    const THEME_KEY = 'fanbridgeTheme';
    function applyTheme(t){
      const dark = (t === 'dark');
      document.body.classList.toggle('dark', dark);
      try { localStorage.setItem(THEME_KEY, dark ? 'dark' : 'light'); } catch(e) {}
      // Update menu item label if present
      const mTheme = document.getElementById('menuTheme');
      if (mTheme) mTheme.textContent = 'Theme: ' + (dark ? 'Dark' : 'Light');
    }
    (function(){
      let pref = 'light';
      try {
        pref = localStorage.getItem(THEME_KEY) ||
          (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
      } catch(e) {}
      applyTheme(pref);
      // Update menu item label if present
      const mTheme = document.getElementById('menuTheme');
      if (mTheme) mTheme.textContent = 'Theme: ' + (pref === 'dark' ? 'Dark' : 'Light');
    })();
  </script>
  <div id="toastHost" class="toast-container" aria-live="polite" aria-atomic="true"></div>
</body>
</html>
