<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="csrf-token" content="{{ csrf_token }}">
  <title>FanBridge</title>
  <!-- FanBridge UI: status, configuration, and modals; minimal client-side JS for polling -->
  <style>
    /* Tabs (distinct from info pills) */
    .tabs {
      display:flex; gap:4px; margin:12px 0; flex-wrap:wrap; max-width: 905px;
      border-bottom: 1px solid var(--border);
    }
    .tab {
      appearance: none;
      border: none;
      background: transparent;
      color: var(--fg);
      padding: 8px 12px;
      margin: 0;
      border-bottom: 3px solid transparent;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      border-radius: 0; /* ensure these are not 'pills' */
    }
    .tab:hover {
      background: var(--pillbg);
    }
    :root { --accent:#ff7a1a; }
    body.dark { --accent:#ffb26b; }
    .tab--active {
      border-bottom-color: var(--accent);
    }
    /* Theme variables */
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
    :root { --bg:#ffffff; --fg:#111827; --muted:#6b7280; --border:#e5e7eb; --thbg:#f6f8fa; --pillbg:#fafafa; --cardbg:#ffffff; }
    body.dark { --bg:#0f172a; --fg:#e5e7eb; --muted:#94a3b8; --border:#334155; --thbg:#111827; --pillbg:#1f2937; --cardbg:#0b1220; }
    body { background: var(--bg); color: var(--fg); }
    .muted { color: var(--muted); }
    table, th, td { border-color: var(--border); }
    th { background: var(--thbg); }
    .pill { border:1px solid var(--border); border-radius:999px; padding:3px 10px; background:var(--pillbg); font-size: 12px; color: var(--fg); }
    button { padding:6px 10px; border:1px solid var(--border); background:var(--pillbg); border-radius:6px; cursor:pointer; color: var(--fg); }
    button:hover { filter: brightness(1.05); }
    a { color: inherit; text-decoration: underline; }
    h1 { margin: 0 0 8px; }
    .meta { color: #666; margin-bottom: 16px; }

    table { border-collapse: collapse; width: 100%; max-width: 905px; }
    th, td { border: 1px solid; padding: 8px 10px; text-align: left; }

    /* State colours */
    .ok   { color: #0a7;   font-weight: 600; }
    .warn { color: #d97706; font-weight: 600; }
    .crit { color: #d32;   font-weight: 700; }

    .flex { display:flex; gap:12px; align-items:center; flex-wrap: wrap; }
    .pill.warn, .pill.error { 
      font-weight: 700;
      border-width: 2px;
    }
    .pill.warn  { border-color:#f59e0b; background:#fff7ed; color:#92400e; }
    .pill.error { border-color:#ef4444; background:#fef2f2; color:#991b1b; }
    .pill.ok    { border-color:#16a34a; background:#ecfdf5; color:#065f46; }
    .warnmsg { color:#b45309; margin:6px 0 0; }
    .errmsg  { color:#991b1b; margin:6px 0 0; }
    .pill.clickable { cursor: pointer; position: relative; }
    .pill.clickable::after { content: " ✎"; opacity: .75; }
    .pill.clickable:hover { filter: brightness(1.06); }
    .small { font-size: 12px; }
    .right { float:right; }
    .footer { margin-top: 16px; }
    code { background:#f6f8fa; padding:2px 6px; border-radius:4px; }

    /* Banners and toasts */
    .banner { display:none; border:1px solid var(--border); border-radius:8px; padding:10px 12px; margin:12px 0; background: var(--pillbg); }
    .banner.warn  { border-color:#f59e0b; background:#fff7ed; color:#92400e; }
    .banner.error { border-color:#ef4444; background:#fef2f2; color:#991b1b; }

    .toast-container { position: fixed; right: 16px; bottom: 16px; display:flex; flex-direction:column; gap:8px; z-index: 2000; }
    .toast { padding:10px 12px; border-radius:8px; border:1px solid var(--border); background: var(--cardbg); box-shadow: 0 6px 18px rgba(0,0,0,.2); min-width: 220px; }
    .toast.info  { border-color:#93c5fd; background:#eff6ff; color:#1e3a8a; }
    .toast.ok    { border-color:#86efac; background:#ecfdf5; color:#065f46; }
    .toast.warn  { border-color:#f59e0b; background:#fff7ed; color:#92400e; }
    .toast.error { border-color:#ef4444; background:#fef2f2; color:#991b1b; }

    .panel { border:1px solid var(--border); border-radius:8px; padding:12px; background: var(--cardbg); max-width: 880px; margin-top:16px; }
    /* Serial tools layout */
    .serial-grid { display:grid; grid-template-columns: minmax(260px, 360px) 1fr; gap:14px; align-items:flex-start; }
    @media (max-width: 880px){ .serial-grid { grid-template-columns: 1fr; } }
    .serial-box { border:1px solid var(--border); border-radius:8px; background: var(--cardbg); padding:10px; }
    .serial-box h3 { margin:0 0 8px; font-size:14px; }
    .serial-console { height: 220px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; background: var(--pillbg); border:1px dashed var(--border); border-radius:8px; padding:8px; white-space: pre-wrap; }
    .serial-console .ts { opacity:.6; }
    .serial-console .in  { color:#2563eb; }
    .serial-console .out { color:#16a34a; }
    .serial-console .err { color:#dc2626; }
    /* Log line emphasis */
    .serial-console .log-warning { color: #d97706; }
    .serial-console .log-error   { color: #dc2626; }
    .serial-row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .serial-row input[type="text"] { flex:1 1 220px; padding:6px 8px; }
    .serial-slider { display:flex; align-items:center; gap:10px; }
    .serial-slider input[type="range"]{ width: 220px; }
    .divider { border-top: 1px solid var(--border); margin: 12px 0; }
    .panel h2 { margin:0 0 8px; font-size:16px; }
    .chk { display:inline-flex; align-items:center; gap:6px; margin:6px 12px 6px 0; }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:6px 12px; }
    .inputs { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    input[type="number"] { width: 72px; padding:4px 6px; }

    /* Table column widths */
    th.type,  td.type  { text-align: center; width: 90px; }
    th.state, td.state { text-align: center; width: 90px; }
    th.temp,  td.temp  { text-align: center; width: 110px; }
    th.inc,   td.inc   { text-align: center; width: 90px; }
    td.inc { text-align:center; }
    input.incl { transform: scale(1.3); accent-color: #16a34a; }

    .grid#curveH_th, .grid#curveH_pw, .grid#curveS_th, .grid#curveS_pw { grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); }
    .grid#curveH_th input, .grid#curveH_pw input, .grid#curveS_th input, .grid#curveS_pw input { width: 64px; }
    .rowlabel { min-width: 110px; }

    /* Form controls */
    input, select {
      background: var(--cardbg);
      color: var(--fg);
      border: 1px solid var(--border);
      color-scheme: light;
    }
    input[type="password"] { width: 100%; padding:6px 8px; }
    body.dark input, body.dark select { color-scheme: dark; }

    /* Dark mode number inputs */
    body.dark input[type="number"]::-webkit-outer-spin-button,
    body.dark input[type="number"]::-webkit-inner-spin-button {
      opacity: 1 !important;
      filter: invert(1) brightness(1.8) contrast(2) drop-shadow(0 0 0.5px #000);
    }

    input[disabled], select[disabled] { opacity: .75; }

    /* Ensure temp cells don't inherit odd backgrounds in dark mode */
    td.temp.ok, td.temp.warn, td.temp.crit { background: transparent !important; text-shadow: none; }

    /* Unraid-style gradient brand title */
    .brand {
      background: linear-gradient(90deg, #e53935 0%, #ff7043 35%, #ff9800 100%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      font-weight: 800;
    }
    /* Compact dropdown menu pill */
    .menu { position: relative; display:inline-block; }
    .menu-list {
      position: absolute; right: 0; top: calc(100% + 6px);
      background: var(--cardbg); color: var(--fg);
      border: 1px solid var(--border); border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      min-width: 180px; padding: 6px;
      z-index: 1500;
    }
    .menu-item {
      display: block; width: 100%; text-align: left;
      padding: 8px 10px; border: none; background: transparent;
      border-radius: 6px; cursor: pointer; color: var(--fg);
    }
    .menu-item:hover { background: var(--pillbg); }
    /* Prevent header pills from overflowing too far; allow wrap neatly */
    .meta { color: #666; margin-bottom: 16px; max-width: 905px; }
  </style>
</head>
<body data-poll="{{ poll_s|int }}" data-version="{{ version or '—' }}">
  <h1 class="brand">FanBridge for Unraid</h1>

  <div class="meta flex">
    <span id="ver"   class="pill">version: {{ version or "—" }}</span>
    <span id="serialpill" class="pill" title="USB serial connection to Arduino / RP2040">serial: …</span>
    <button id="pollbtn" class="pill clickable" type="button" title="Click to change the refresh interval (3–60 seconds)">refresh: …</button>
    <span id="mtime" class="pill">disks.ini: …</span>
    <span id="updated" class="pill" title="">updated: …</span>
    <div class="menu">
      <button id="menuBtn" class="pill" type="button" aria-haspopup="true" aria-expanded="false">Menu ▾</button>
      <div id="menuList" class="menu-list" role="menu" aria-labelledby="menuBtn" style="display:none;">
        <button id="menuTheme"  class="menu-item" role="menuitem">Theme: …</button>
        <button id="menuPw"     class="menu-item" role="menuitem">Change password</button>
        <button id="menuLogout" class="menu-item" role="menuitem">Logout</button>
      </div>
    </div>
  </div>

  <div class="tabs">
    <button class="tab tab--active" data-tab="main" id="tab-main">Drives &amp; Config</button>
    <button class="tab" data-tab="serial" id="tab-serial">Serial</button>
    <button class="tab" data-tab="logs" id="tab-logs">Logs</button>
  </div>

  <div id="statusBanner" class="banner warn"></div>

  <div id="panel-main">
  <table id="tbl">
    <thead>
      <tr>
        <th>Device</th>
        <th class="type">Type</th>
        <th class="state">State</th>
        <th class="temp">Temp (°C)</th>
        <th class="inc">Included</th>
      </tr>
    </thead>
    <tbody id="rows">
      <tr><td colspan="5" class="muted">Loading…</td></tr>
    </tbody>
    <tfoot>
      <tr>
        <th colspan="5">
          HDD avg/min/max: <span id="hddstats" class="small muted">—</span> &nbsp; | &nbsp;
          SSD avg/min/max: <span id="ssdstats" class="small muted">—</span> &nbsp; | &nbsp;
          Recommended PWM: <strong id="pwm">—</strong>
        </th>
      </tr>
    </tfoot>
  </table>

  <div class="panel">
    <div class="config-header" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
      <h1 style="margin:0;">Configuration</h1>
      <div class="config-actions" style="display:flex; align-items:center; gap:10px;">
        <div id="configFlags" style="display:flex; gap:8px; align-items:center;">
          <span id="dirtyFlag" class="pill warn" style="display:none;">Unsaved changes</span>
          <span id="valFlag" class="pill error" style="display:none;">Fix validation errors</span>
        </div>
        <label class="chk" title="Automatically send recommended PWM to the controller when connected">
          <input type="checkbox" id="auto_apply">
          <span>Apply to controller</span>
        </label>
        <span id="auto_info" class="pill small" title="Last applied duty and time" style="display:none;">—</span>
        <button id="resetDefaults" class="pill" type="button" title="Reset overrides and fan curves to defaults">Reset to defaults</button>
  </div>
</div>

  <!-- Modal: Refresh Interval -->
  <div id="pollModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.45); align-items:center; justify-content:center; z-index:1000;">
    <div style="background: var(--cardbg); color: var(--fg); border:1px solid var(--border); border-radius:10px; padding:16px; width: min(420px, 92vw); box-shadow: 0 10px 30px rgba(0,0,0,.3);">
      <h3 style="margin:0 0 10px;">Set refresh interval</h3>
      <p class="small" style="margin:0 0 10px; color:var(--muted);">
        Choose how often the page polls Unraid for drive temperatures (3–60 seconds).
      </p>
      <div class="inputs" style="align-items:center;">
        <label for="poll_input">Seconds</label>
        <input type="number" id="poll_input" min="3" max="60" step="1" value="7" style="width:96px;">
      </div>
      <div id="poll_error" class="small" style="margin-top:8px; color:#b91c1c;"></div>
      <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:14px;">
        <button id="poll_cancel">Cancel</button>
        <button id="poll_save">Save</button>
      </div>
    </div>
  </div>

    <h2>Single Drive Max Overrides</h2>
    <div class="inputs">
      <label>HDD  (°C): <input type="number" id="hddovr" min="30" max="70" step="1"></label>
      <label>SSD  (°C): <input type="number" id="ssdovr" min="40" max="90" step="1"></label>
      <button id="savebtn">Save</button>
      <button id="discardbtn" style="display:none;">Discard</button>
    </div>

    <h2 style="margin-top:10px;">Auto-apply settings</h2>
    <div class="inputs">
      <label>Min interval (s): <input type="number" id="auto_min" min="1" max="60" step="1"></label>
      <label>Hysteresis (duty 0–255): <input type="number" id="auto_hyst" min="0" max="64" step="1"></label>
    </div>
    <div class="divider"></div>

    <h2 style="margin-bottom:8px;">Fan curves</h2>
    <div class="small muted" style="margin-bottom:10px;">
      Set the fan curve from temperature to PWM. Left to right = increasing temperature.
    </div>

    <h2 style="margin:6px 0 6px;">HDD fan curve</h2>
    <div class="inputs" style="align-items:flex-start;">
      <div class="rowlabel small muted" style="width:130px;">Thresholds (°C)</div>
      <div class="grid" id="curveH_th"></div>
    </div>
    <div class="inputs" style="align-items:flex-start; margin-top:6px;">
      <div class="rowlabel small muted" style="width:130px;">PWM (%)</div>
      <div class="grid" id="curveH_pw"></div>
      <div id="curveH_warn" class="warnmsg small" style="display:none;"></div>
    </div>

    <h2 style="margin:12px 0 6px;">SSD fan curve</h2>
    <div class="inputs" style="align-items:flex-start;">
      <div class="rowlabel small muted" style="width:130px;">Thresholds (°C)</div>
      <div class="grid" id="curveS_th"></div>
    </div>
    <div class="inputs" style="align-items:flex-start; margin-top:6px;">
      <div class="rowlabel small muted" style="width:130px;">PWM (%)</div>
      <div class="grid" id="curveS_pw"></div>
      <div id="curveS_warn" class="warnmsg small" style="display:none;"></div>
    </div>

    <div class="inputs" style="margin-top:10px;">
      <button id="savecurves" disabled>Save</button>
      <button id="discardcurves" style="display:none;">Discard</button>
    </div>
  </div>

  <div class="footer small muted">
    <a href="/api/status">API</a> &nbsp;|&nbsp; <a href="/health">Health</a>
  </div>
</div> <!-- /#panel-main -->

<div id="panel-serial" style="display:none;">
  <div class="panel">
    <h2 style="margin:0 0 10px; display:flex; align-items:center; gap:10px;">
      Serial tools
      <span id="serialStatus" class="pill small" title="USB serial connection status">checking…</span>
    </h2>

    <div class="serial-grid">
      <!-- Left: quick actions -->
      <div class="serial-box">
        <h3>Quick commands</h3>
        <div class="serial-row" style="margin-bottom:8px;">
          <button id="btnPing">PING</button>
          <button id="btnTest">TEST</button>
          <button id="btnVer">VERSION</button>
          <button id="btnStat">STATUS</button>
        </div>

        <h3 style="margin-top:12px;">Send raw line</h3>
        <div class="serial-row">
          <input type="text" id="serialLine" placeholder="Type a command e.g. 50 (percent)" />
          <button id="btnSendLine">Send</button>
        </div>

        <h3 style="margin-top:12px;">PWM test</h3>
        <div class="serial-slider">
          <input type="range" id="pwmRange" min="0" max="100" value="0" />
          <span class="small muted">value: <strong id="pwmVal">0</strong>%</span>
          <button id="btnPwmSend">Apply</button>
          <button id="btnPwmZero">Zero</button>
        </div>
      </div>

      <!-- Right: console output -->
      <div class="serial-box">
        <h3>Console</h3>
        <div id="serialConsole" class="serial-console" aria-live="polite" aria-atomic="false"></div>
      </div>
    </div>
  </div>

  <div class="panel">
    <h2 style="margin:0 0 10px; display:flex; align-items:center; gap:10px;">
      Link Updates
      <span id="rpPriv" class="pill small" title="Container privileges">privileged: …</span>
      <span id="rpUpd" class="pill small" title="Update availability">update: …</span>
    </h2>
    <div class="serial-grid">
      <div class="serial-box">
        <h3>Device</h3>
        <div class="small">
          <div>Port: <span id="rpPort">—</span></div>
          <div>USB: <span id="rpUsb">—</span></div>
          <div>Manufacturer: <span id="rpMan">—</span></div>
          <div>Product: <span id="rpProd">—</span></div>
          <div>Serial: <span id="rpSer">—</span></div>
          <div>Controller version: <span id="rpVer">—</span></div>
        </div>
      </div>
      <div class="serial-box">
        <h3>Link Updates</h3>
        <div class="serial-row" style="margin-bottom:8px;">
          <input type="text" id="rpRepoUrl" placeholder="https://…/manifest.json base" />
          <button id="rpSaveRepo">Save URL</button>
        </div>
        <div class="small">
          <div>Board: <span id="rpBoard">rp2040</span></div>
          <div>Latest: <span id="rpLatest">—</span></div>
          <div>Manifest: <a id="rpManifest" href="#" target="_blank" rel="noopener">—</a></div>
        </div>
        <div class="serial-row" style="margin-top:10px;">
          <button id="rpFlashLatest" disabled title="Coming soon">Coming soon</button>
        </div>
        <div id="rpWarn" class="warnmsg small" style="display:none;"></div>
      </div>
    </div>
  </div>
</div>

  <div id="panel-logs" style="display:none;">
    <div class="panel">
      <h2 style="margin:0 0 10px; display:flex; align-items:center; gap:10px;">Logs</h2>
    <div class="inputs" style="margin:6px 0 10px;">
      <label>Runtime level:
        <select id="log_level">
          <option value="NORMAL" selected>Normal</option>
          <option value="DEBUG">Debug</option>
        </select>
      </label>
      <span class="small muted">Normal includes warnings/errors; Debug adds verbose diagnostics.</span>
    </div>
      <div class="inputs" style="margin:6px 0 10px;">
        <label class="chk"><input type="checkbox" class="logfilter" value="ERROR" checked> ERROR</label>
        <label class="chk"><input type="checkbox" class="logfilter" value="WARNING" checked> WARNING</label>
        <label class="chk"><input type="checkbox" class="logfilter" value="INFO" checked> INFO</label>
        <label class="chk"><input type="checkbox" class="logfilter" value="DEBUG"> DEBUG</label>
        <span class="small muted">Client-side view filter</span>
      </div>
      <div class="inputs" style="margin:6px 0 10px; align-items: flex-end;">
        <div>
          <label>Download as:
            <select id="log_dl_fmt">
              <option value="text" selected>Text (.txt)</option>
              <option value="json">JSON (.json)</option>
            </select>
          </label>
        </div>
        <div>
          <label>From: <input type="datetime-local" id="log_from"/></label>
        </div>
        <div>
          <label>To: <input type="datetime-local" id="log_to"/></label>
        </div>
        <button id="log_dl_btn">Download</button>
        <button id="log_clear_btn" title="Clear in-memory log buffer">Clear logs</button>
        <span class="small muted">Download uses current view’s minimum level and optional time window.</span>
      </div>
      <div id="logbox" class="serial-console" style="height:320px;"></div>
    </div>
  </div>

  <!-- Modal: RP Flash Confirm -->
  <div id="rpFlashConfirm" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.45); align-items:center; justify-content:center; z-index:1100;">
    <div style="background: var(--cardbg); color: var(--fg); border:1px solid var(--border); border-radius:10px; padding:16px; width: min(520px, 92vw); box-shadow: 0 10px 30px rgba(0,0,0,.3);">
      <h3 style="margin:0 0 10px;">Install latest firmware</h3>
      <p class="small" style="margin:0 0 10px; color:var(--muted);">
        The controller will reboot into BOOTSEL mode, the UF2 will be copied, and then it will reconnect. Do not unplug it during the process.
      </p>
      <div style="display:flex; gap:10px; justify-content:flex-end;">
        <button id="rpFlashCancel">Cancel</button>
        <button id="rpFlashConfirmBtn">Install</button>
      </div>
    </div>
  </div>

  <!-- Modal: RP Flash Progress -->
  <div id="rpFlashProgress" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.45); align-items:center; justify-content:center; z-index:1200;">
    <div style="background: var(--cardbg); color: var(--fg); border:1px solid var(--border); border-radius:10px; padding:16px; width: min(720px, 96vw); box-shadow: 0 10px 30px rgba(0,0,0,.3);">
      <h3 style="margin:0 0 10px;">Firmware update</h3>
      <div id="rpProgLog" class="serial-console" style="height:280px;">
        <div class="line">Preparing…</div>
      </div>
      <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:10px;">
        <button id="rpProgClose" disabled>Close</button>
      </div>
    </div>
  </div>

  <!-- Modal: Change Password -->
  <div id="pwModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.45); align-items:center; justify-content:center; z-index:1000;">
    <div style="background: var(--cardbg); color: var(--fg); border:1px solid var(--border); border-radius:10px; padding:16px; width: min(420px, 92vw); box-shadow: 0 10px 30px rgba(0,0,0,.3);">
      <h3 style="margin:0 0 10px;">Change password</h3>
      <div class="inputs" style="flex-direction:column; align-items:stretch; gap:10px;">
        <label>Current password
          <input type="password" id="pw_current" autocomplete="current-password">
        </label>
        <label>New password
          <input type="password" id="pw_new" autocomplete="new-password">
        </label>
        <label>Confirm new password
          <input type="password" id="pw_confirm" autocomplete="new-password">
        </label>
      </div>
      <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:14px;">
        <button id="pw_cancel">Cancel</button>
        <button id="pw_save">Save</button>
      </div>
      <div id="pw_error" class="small muted" style="margin-top:8px; color:#b91c1c;"></div>
    </div>
  </div>

  <!-- Modal: Reset to Defaults -->
  <div id="resetModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.45); align-items:center; justify-content:center; z-index:1000;">
    <div style="background: var(--cardbg); color: var(--fg); border:1px solid var(--border); border-radius:10px; padding:16px; width: min(420px, 92vw); box-shadow: 0 10px 30px rgba(0,0,0,.3);">
      <h3 style="margin:0 0 10px;">Reset to defaults</h3>
      <p class="small" style="margin:0 0 10px; color:var(--muted);">
        This will restore the single‑drive temperature overrides and both fan curves to their factory defaults.
      </p>
      <p style="margin:0 0 12px; font-weight:600;">Are you sure you want to proceed?</p>
      <div style="display:flex; gap:10px; justify-content:flex-end;">
        <button id="reset_cancel">Cancel</button>
        <button id="reset_confirm">Reset</button>
      </div>
      <div id="reset_error" class="small" style="margin-top:8px; color:#b91c1c;"></div>
    </div>
  </div>


  <script>
    let pollSeconds = parseInt(document.body.dataset.poll || '7', 10);
    // tabs: minimal show/hide
    const panels = {
      main: document.getElementById('panel-main'),
      serial: document.getElementById('panel-serial'),
      logs: document.getElementById('panel-logs'),
    };
    function showTab(name){
      Object.keys(panels).forEach(k=>{
        if (panels[k]) panels[k].style.display = (k===name) ? '' : 'none';
        const btn = document.getElementById('tab-'+k);
        if (btn) btn.classList.toggle('tab--active', k===name);
      });
      try { localStorage.setItem('fanbridgeTab', name); } catch(e){}
      // Trigger immediate updates on tab switch
      try { if (name === 'serial' && typeof refreshSerial === 'function') refreshSerial(); } catch(e){}
      try { if (name === 'serial' && typeof refreshRp === 'function') refreshRp(); } catch(e){}
      try { if (name === 'logs') startLogs(); else stopLogs(); } catch(e){}
    }
    document.querySelectorAll('.tabs .tab[data-tab]').forEach(b=>{
      b.addEventListener('click', ()=> showTab(b.dataset.tab));
    });
    showTab((()=>{
      try { return localStorage.getItem('fanbridgeTab') || 'main'; } catch(e) { return 'main'; }
    })());
    let pollTimer = null;
    let pollTimerSerial = null;
    function startPolling(){
      if (pollTimer) clearInterval(pollTimer);
      if (pollTimerSerial) clearInterval(pollTimerSerial);
      const ms = Math.max(3, Math.min(60, pollSeconds))*1000;
      pollTimer = setInterval(refresh, ms);
      pollTimerSerial = setInterval(refreshSerial, ms);
      const pb = document.getElementById('pollbtn');
      if (pb) pb.textContent = `refresh: every ${Math.max(3, Math.min(60, pollSeconds))}s`;
      if (pb) pb.title = 'Click to change the refresh interval (3–60 seconds)';
    }
    // Logs polling
    let logsTimer = null;
    let logsSince = 0;
    let logFilters = new Set(['ERROR','WARNING','INFO']);
    function logsAppend(items){
      const box = document.getElementById('logbox');
      if (!box) return;
      const frag = document.createDocumentFragment();
      for (const it of items){
        if (!logFilters.has(String(it.level).toUpperCase())) continue;
        const line = document.createElement('div');
        const ts = new Date((it.ts||0)*1000).toLocaleTimeString();
        const lvl = String(it.level || '').toUpperCase();
        const lvlCls = (lvl === 'ERROR') ? 'log-error' : (lvl === 'WARNING') ? 'log-warning' : '';
        line.className = 'line' + (lvlCls ? (' ' + lvlCls) : '');
        line.innerHTML = `<span class=\"ts\">${ts}</span> <strong>[${it.level}]</strong> <span class=\"muted\">${it.name}</span> ${it.msg}`;
        frag.appendChild(line);
      }
      box.appendChild(frag);
      box.scrollTop = box.scrollHeight;
    }
    async function logsTick(){
      try{
        const r = await fetch(`/api/logs?since=${logsSince}&min_level=DEBUG&limit=400`, { cache:'no-store' });
        const j = await r.json();
        if (j && j.items && j.items.length){
          logsAppend(j.items);
          logsSince = j.last_id || logsSince;
        }
        const sel = document.getElementById('log_level');
        if (sel && typeof j.level === 'number'){
          // Map numeric level to our simplified choices
          sel.value = (j.level <= 10) ? 'DEBUG' : 'NORMAL';
        }
      }catch(e){ }
    }
    function startLogs(){ if (logsTimer) clearInterval(logsTimer); logsTimer = setInterval(logsTick, 2000); logsTick(); }
    function stopLogs(){ if (logsTimer) clearInterval(logsTimer); logsTimer = null; }
    // Serial status updater
    async function refreshSerial(){
      const el = document.getElementById('serialpill');
      if (!el) return;
      try {
        const r = await fetch('/api/serial/status', { cache: 'no-store' });
        const j = await r.json();
        if (j.connected) {
          el.textContent = 'serial: connected';
          el.title = (j.preferred ? `Using ${j.preferred}` : (j.ports && j.ports[0] ? `Using ${j.ports[0]}` : 'connected'));
          el.classList.remove('error','warn');
          el.classList.add('ok');
        } else {
          const hint = (j.ports && j.ports.length) ? 'not opened (permission?)' : 'not found';
          el.textContent = 'serial: ' + hint;
          el.title = (j.ports && j.ports.length)
            ? `Found: ${j.ports.join(', ')}. Map the correct device in the Unraid template (Add another Path, Port, Variable, Label or Device ➜ Device).`
            : 'No serial devices visible in container. Map /dev/ttyACM* or /dev/ttyUSB* via the template.';
          el.classList.remove('error','ok');
          el.classList.add('warn');
        }
      } catch (e) {
        el.textContent = 'serial: error';
        el.title = 'Failed to query /api/serial/status';
        el.classList.remove('warn');
        el.classList.add('error');
      }
    }

    // RP status updater
    async function refreshRp(){
      const priv = document.getElementById('rpPriv');
      const upd  = document.getElementById('rpUpd');
      const port = document.getElementById('rpPort');
      const usb  = document.getElementById('rpUsb');
      const man  = document.getElementById('rpMan');
      const prod = document.getElementById('rpProd');
      const ser  = document.getElementById('rpSer');
      const ver  = document.getElementById('rpVer');
      const repo = document.getElementById('rpRepoUrl');
      const board= document.getElementById('rpBoard');
      const latest = document.getElementById('rpLatest');
      const manifest = document.getElementById('rpManifest');
      // Preferred RP2 device field removed (coming soon)
      const warn = document.getElementById('rpWarn');
      try{
        warn.style.display='none'; warn.textContent='';
      }catch(e){}
      try {
        const r = await fetch('/api/rp/status', { cache: 'no-store' });
        const j = await r.json();
        if (priv){
          priv.textContent = 'privileged: ' + (j.privileged ? 'yes' : 'no');
          priv.className = 'pill small ' + (j.privileged ? 'ok' : 'warn');
        }
        if (upd){
          upd.textContent = 'update: ' + (j.update_available ? 'available' : 'none');
          upd.className = 'pill small ' + (j.update_available ? 'warn' : '');
          upd.title = j.latest && j.latest.version && j.controller_version ? (`latest ${j.latest.version} vs current ${j.controller_version}`) : '';
        }
        if (port) port.textContent = fmt(j.serial && j.serial.preferred);
        const u = j.usb || {};
        if (usb) usb.textContent = (u.vid && u.pid) ? `vid:pid ${u.vid}:${u.pid}` : '—';
        if (man) man.textContent = fmt(u.manufacturer);
        if (prod) prod.textContent = fmt(u.product);
        if (ser) ser.textContent = fmt(u.serial_number);
        if (ver) ver.textContent = fmt(j.controller_version);
        if (repo) repo.value = j.repo_url || repo.value || '';
        if (rp2Dev) rp2Dev.value = j.rp2_device || rp2Dev.value || '';
        if (board) board.textContent = j.board || 'rp2040';
        if (latest) latest.textContent = j.latest ? `${j.latest.board}-${j.latest.version}` : '—';
        if (manifest){ manifest.textContent = j.manifest_url || '—'; manifest.href = j.manifest_url || '#'; }
        if (!j.privileged){
          if (warn){ warn.style.display=''; warn.textContent='Container is not privileged; flashing may fail to detect/mount RPI-RP2.'; }
        }
      } catch(e){
        if (priv){ priv.textContent = 'privileged: ?'; priv.className='pill small'; }
        if (upd){ upd.textContent='update: ?'; upd.className='pill small'; }
      }
    }
    const fmt = (v) => (v === null || v === undefined) ? "—" : v;
    const CSRF = document.querySelector('meta[name="csrf-token"]').content;

    // Status formatting helpers
    function formatAge(ms){
      if (ms <= 0 || isNaN(ms)) return 'n/a';
      const s = Math.floor(ms/1000);
      const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), ss = s%60;
      if (h>0) return `${h}:${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')} ago`;
      return `${m}:${String(ss).padStart(2,'0')} ago`;
    }
    function setBanner(msg, type='warn'){
      const b = document.getElementById('statusBanner');
      if (!b) return;
      if (!msg) { b.style.display='none'; b.textContent=''; b.classList.remove('warn','error'); return; }
      b.textContent = msg;
      b.classList.remove('warn','error');
      b.classList.add(type);
      b.style.display='block';
    }
    function showToast(msg, type='ok', timeoutMs=3000){
      const host = document.getElementById('toastHost');
      if (!host) return;
      const el = document.createElement('div');
      el.className = `toast ${type}`;
      el.textContent = msg;
      host.appendChild(el);
      setTimeout(()=>{ el.style.opacity='0'; el.style.transition='opacity .25s'; setTimeout(()=> el.remove(), 260); }, timeoutMs);
    }

    // dynamic colour class based on per-type override thresholds
    let OVERRIDE_HDD = 45;
    let OVERRIDE_SSD = 60;
    const WARN_DELTA = 5; // orange when within 5°C of override
    let HTH = [], HPW = [], STH = [], SPW = [];
    let DIRTY_OVR = false;   // overrides edited but not saved
    let DIRTY_CURVES = false; // fan curves edited but not saved

    function setDirty(which, v=true){
      if(which === 'ovr') DIRTY_OVR = v; else if(which === 'curves') DIRTY_CURVES = v;
      const any = DIRTY_OVR || DIRTY_CURVES;
      document.getElementById('dirtyFlag').style.display = any ? '' : 'none';
      document.getElementById('discardbtn').style.display = DIRTY_OVR ? '' : 'none';
      document.getElementById('discardcurves').style.display = DIRTY_CURVES ? '' : 'none';
    }
    
    // ---- Curve validation helpers ----
function isStrictlyIncreasing(arr){
  for (let i=1;i<arr.length;i++){ if (!(arr[i] > arr[i-1])) return false; }
  return true;
}
function isNonDecreasing01(arr){
  for (let i=0;i<arr.length;i++){
    const v = arr[i];
    if (isNaN(v) || v < 0 || v > 100) return false;
    if (i>0 && v < arr[i-1]) return false;
  }
  return true;
}
function validatePair(th, pw){
  if (th.length !== pw.length) return { ok:false, msg:`Lengths differ (thresholds=${th.length}, pwm=${pw.length}).` };
  if (th.length === 0) return { ok:false, msg:'Add at least one step.' };
  if (!isStrictlyIncreasing(th)) return { ok:false, msg:'Thresholds must increase (e.g. 25, 28, 32...).' };
  if (!isNonDecreasing01(pw)) return { ok:false, msg:'PWM must be 0–100 and non-decreasing (e.g. 0, 10, 10, 20...).' };
  return { ok:true, msg:'' };
}
function gatherCurveInputs(containerId){
  return Array.from(document.querySelectorAll(`#${containerId} input`)).map(i=>parseInt(i.value||'0',10));
}
function showWarn(id, msg){
  const el = document.getElementById(id);
  if (!el) return;
  if (msg){ el.textContent = msg; el.style.display=''; }
  else { el.textContent=''; el.style.display='none'; }
}
function applyValidation(){
  // read current editors (fall back to arrays if inputs not yet built)
  const hth = document.querySelectorAll('#curveH_th input').length ? gatherCurveInputs('curveH_th') : HTH.slice();
  const hpw = document.querySelectorAll('#curveH_pw input').length ? gatherCurveInputs('curveH_pw') : HPW.slice();
  const sth = document.querySelectorAll('#curveS_th input').length ? gatherCurveInputs('curveS_th') : STH.slice();
  const spw = document.querySelectorAll('#curveS_pw input').length ? gatherCurveInputs('curveS_pw') : SPW.slice();
  const vh = validatePair(hth, hpw);
  const vs = validatePair(sth, spw);
  showWarn('curveH_warn', vh.ok ? '' : vh.msg);
  showWarn('curveS_warn', vs.ok ? '' : vs.msg);
  const saveBtn = document.getElementById('savecurves');
  const valFlag = document.getElementById('valFlag');
  const ok = vh.ok && vs.ok;
  if (saveBtn) saveBtn.disabled = !ok;
  if (valFlag) valFlag.style.display = ok ? 'none' : '';
}

    const clsForTemp = (t, type) => {
      if (t === null || t === undefined) return "muted";
      const thr = (String(type).toUpperCase() === 'SSD') ? OVERRIDE_SSD : OVERRIDE_HDD;
      if (t >= thr) return "crit";
      if (t >= (thr - WARN_DELTA)) return "warn";
      return "ok";
    };

    // --- fetch with timeout helper (to avoid hanging connections) ---
    async function fetchWithTimeout(url, options = {}, timeoutMs = 12000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeoutMs);
      try {
        const resp = await fetch(url, { ...options, signal: controller.signal });
        return resp;
      } finally {
        clearTimeout(id);
      }
    }

    async function refresh() {
      try {
        // extend timeout to tolerate slower disks.ini reads / network hiccups
        const r = await fetchWithTimeout('/api/status', { cache: 'no-store' }, Math.max(10000, Math.min(25000, (pollSeconds || 7) * 2000)));
        const j = await r.json();

        const VERSION_FALLBACK = document.body.dataset.version || '—';
        document.getElementById('ver').textContent = 'version: ' + (j.version || VERSION_FALLBACK);
        document.getElementById('pwm').textContent = (j.recommended_pwm ?? '—') + '%';

        const now = new Date();
        const updEl = document.getElementById('updated');
        updEl.textContent = 'updated: ' + now.toLocaleTimeString();
        updEl.title = 'FanBridge last fetched /api/status at: ' + now.toLocaleString();

        // disks.ini mtime pill + banner logic
        const mtEl = document.getElementById('mtime');
        let mtLabel = 'n/a';
        let bannerMsg = '';
        if (j.disks_ini_mtime){
          const wrote = j.disks_ini_mtime * 1000;
          mtLabel = formatAge(Date.now() - wrote);
          mtEl.title = 'Unraid wrote /var/local/emhttp/disks.ini at: ' + new Date(wrote).toLocaleString();
          if ((Date.now() - wrote) > 60000) bannerMsg = 'Warning: /unraid/disks.ini appears stale (older than 60s).';
        } else {
          mtEl.title = 'disks.ini timestamp not available';
          bannerMsg = 'Could not read /unraid/disks.ini (is the path mapped read-only to the container?)';
        }
        mtEl.textContent = 'disks.ini: ' + mtLabel;
        setBanner(bannerMsg || '', bannerMsg ? 'warn' : 'warn');

        // sync dynamic thresholds from server so colours reflect current settings
        if (typeof j.override_hdd_c === 'number') OVERRIDE_HDD = j.override_hdd_c;
        if (typeof j.override_ssd_c === 'number') OVERRIDE_SSD = j.override_ssd_c;
        if (Array.isArray(j.hdd_thresholds)) HTH = j.hdd_thresholds.slice();
        if (Array.isArray(j.hdd_pwm)) HPW = j.hdd_pwm.slice();
        if (Array.isArray(j.ssd_thresholds)) STH = j.ssd_thresholds.slice();
        if (Array.isArray(j.ssd_pwm)) SPW = j.ssd_pwm.slice();

        // Auto-apply UI: reflect server state
        const aa = document.getElementById('auto_apply');
        if (aa) aa.checked = !!j.auto_apply;
        const ai = document.getElementById('auto_info');
        if (ai) {
          const duty = (j.auto_last_duty !== null && j.auto_last_duty !== undefined) ? j.auto_last_duty : null;
          const pct = (typeof duty === 'number') ? Math.round((Math.max(0, Math.min(255, duty)) * 100) / 255) : null;
          const when = (j.auto_last_ts ? new Date(j.auto_last_ts * 1000).toLocaleTimeString() : null);
          const paused = !!j.auto_paused;
          if (pct !== null) {
            ai.style.display = '';
            ai.textContent = `sent: ${pct}% @ ${when || '—'}`;
            ai.className = 'pill small' + (paused ? ' warn' : '');
            const extra = (typeof duty === 'number') ? ` (${duty}/255)` : '';
            ai.title = j.auto_message || (paused ? `paused${extra}` : `last sent duty and time${extra}`);
          } else {
            ai.style.display = j.auto_apply ? '' : 'none';
            ai.textContent = paused ? 'paused' : '—';
            ai.className = 'pill small' + (paused ? ' warn' : '');
            ai.title = j.auto_message || '';
          }
        }

        // Populate auto-apply tuning inputs
        const am = document.getElementById('auto_min');
        const ah = document.getElementById('auto_hyst');
        if (am && typeof j.auto_apply_min_interval_s === 'number') am.value = j.auto_apply_min_interval_s;
        if (ah && typeof j.auto_apply_hysteresis_duty === 'number') ah.value = j.auto_apply_hysteresis_duty;

        const rows = document.getElementById('rows');
        rows.innerHTML = '';
        if (!j.drives || j.drives.length === 0) {
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 5;
          td.className = 'muted';
          td.textContent = 'No drives detected.';
          tr.appendChild(td);
          rows.appendChild(tr);
        }
        (j.drives || []).forEach(d => {
          const tr = document.createElement('tr');
          const tdDev = document.createElement('td'); tdDev.textContent = d.dev ? (d.slot ? (d.dev + ' (' + d.slot + ')') : d.dev) : '—';
          const tdType = document.createElement('td'); tdType.textContent = d.type || '—'; tdType.className = 'type';
          const tdState = document.createElement('td'); tdState.textContent = d.state || '—'; tdState.className = 'state';
          const tdTemp = document.createElement('td'); tdTemp.textContent = fmt(d.temp); tdTemp.className = 'temp ' + clsForTemp(d.temp, d.type);
          const tdInc = document.createElement('td'); tdInc.className = 'inc';

          const cbInc = document.createElement('input');
          cbInc.type = 'checkbox';
          cbInc.className = 'incl';
          cbInc.checked = !d.excluded; // checked means INCLUDED in calculations
          cbInc.onchange = async (e) => {
            try {
              await fetch('/api/exclude', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': CSRF },
                body: JSON.stringify({ dev: d.dev, excluded: !e.target.checked })
              });
            } catch (err) { console.error(err); }
          };
          tdInc.appendChild(cbInc);

          tr.append(tdDev, tdType, tdState, tdTemp, tdInc);
          rows.appendChild(tr);
        });

        const hs = j.hdd || {}, ss = j.ssd || {};
        document.getElementById('hddstats').textContent = (fmt(hs.avg) + ' / ' + fmt(hs.min) + ' / ' + fmt(hs.max) + '  (n=' + fmt(hs.count) + ')');
        document.getElementById('ssdstats').textContent = (fmt(ss.avg) + ' / ' + fmt(ss.min) + ' / ' + fmt(ss.max) + '  (n=' + fmt(ss.count) + ')');

        // populate override inputs only if not being edited (dirty)
        if (!DIRTY_OVR) {
          if (typeof j.override_hdd_c !== 'undefined') document.getElementById('hddovr').value = j.override_hdd_c;
          if (typeof j.override_ssd_c !== 'undefined') document.getElementById('ssdovr').value = j.override_ssd_c;
        }

        // populate fan curve editors (skip if user is editing to prevent overwrites)
        if (!DIRTY_CURVES) {
          const ch_th = document.getElementById('curveH_th'); ch_th.innerHTML='';
          const ch_pw = document.getElementById('curveH_pw'); ch_pw.innerHTML='';
          const cs_th = document.getElementById('curveS_th'); cs_th.innerHTML='';
          const cs_pw = document.getElementById('curveS_pw'); cs_pw.innerHTML='';

          const makeNum = (val)=>{ const i=document.createElement('input'); i.type='number'; i.min='0'; i.max='100'; i.step='1'; i.value = val; i.addEventListener('input', ()=> setDirty('curves', true)); return i; };

          const nH = Math.max(HTH.length, HPW.length) || 1;
          const nS = Math.max(STH.length, SPW.length) || 1;
          ch_th.style.gridTemplateColumns = `repeat(${nH}, minmax(70px, 1fr))`;
          ch_pw.style.gridTemplateColumns = `repeat(${nH}, minmax(70px, 1fr))`;
          cs_th.style.gridTemplateColumns = `repeat(${nS}, minmax(70px, 1fr))`;
          cs_pw.style.gridTemplateColumns = `repeat(${nS}, minmax(70px, 1fr))`;

          for (let i=0;i<nH;i++) { ch_th.appendChild(makeNum(HTH[i]!==undefined?HTH[i]:0)); ch_pw.appendChild(makeNum(HPW[i]!==undefined?HPW[i]:0)); }
          for (let i=0;i<nS;i++) { cs_th.appendChild(makeNum(STH[i]!==undefined?STH[i]:0)); cs_pw.appendChild(makeNum(SPW[i]!==undefined?SPW[i]:0)); }
          // validate after rebuilding editors
          document.querySelectorAll('#curveH_th input, #curveH_pw input, #curveS_th input, #curveS_pw input')
            .forEach(inp => inp.addEventListener('input', applyValidation));
          // Initial validation state
          applyValidation();
        }

        // If we successfully refreshed (i.e., no fetch error) and there is no stale warning, clear any error banner.
        const sb = document.getElementById('statusBanner');
        if (sb && sb.style.display === 'block' && !bannerMsg) {
          setBanner('');
        }
      } catch (e) {
        console.error(e);
        setBanner('Unable to fetch /api/status — check container is running and network is reachable.', 'error');
        if (e.name === 'AbortError') {
          console.warn('Status fetch aborted due to timeout.');
        }
      }
    }

    refresh();
    refreshSerial();
    startPolling();

    // --- Themed Refresh Interval Modal ---
    (function(){
      const btn = document.getElementById('pollbtn');
      const modal = document.getElementById('pollModal');
      const inp = document.getElementById('poll_input');
      const cancelBtn = document.getElementById('poll_cancel');
      const saveBtn = document.getElementById('poll_save');
      const err = document.getElementById('poll_error');

      function openModal(){
        if (!modal) return;
        if (err) err.textContent = '';
        if (inp) inp.value = String(Math.max(3, Math.min(60, pollSeconds || 7)));
        modal.style.display = 'flex';
        setTimeout(()=> inp && inp.focus(), 0);
      }
      function closeModal(){ if (modal) modal.style.display = 'none'; }

      if (btn) btn.addEventListener('click', openModal);
      if (cancelBtn) cancelBtn.addEventListener('click', closeModal);
      if (modal) modal.addEventListener('click', (ev)=>{ if (ev.target === modal) closeModal(); });

      async function savePoll(){
        if (!inp) return;
        if (err) err.textContent = '';
        let val = parseInt(inp.value, 10);
        if (isNaN(val)) { if (err) err.textContent = 'Please enter a number between 3 and 60.'; return; }
        if (val < 3) val = 3;
        if (val > 60) val = 60;

        try {
          // Update UI + timer
          pollSeconds = val;
          document.body.dataset.poll = String(val);
          startPolling();

          // Persist to server
          const r = await fetch('/api/settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': CSRF },
            body: JSON.stringify({ poll_interval_seconds: val })
          });
          if (!r.ok) {
            if (err) err.textContent = 'Failed to save. Please try again.';
            showToast('Failed to save refresh interval', 'error');
            return;
          }
          showToast(`Refresh set to ${val}s`, 'ok');
          closeModal();
        } catch(e){
          console.error(e);
          if (err) err.textContent = 'Unexpected error.';
          showToast('Error saving refresh interval', 'error');
        }
      }
      if (saveBtn) saveBtn.addEventListener('click', savePoll);
      if (inp) inp.addEventListener('keydown', (ev)=>{ if (ev.key === 'Enter') savePoll(); });
    })();

    // --- Dropdown Menu (Theme / Change password / Logout) ---
    (function(){
      const btn   = document.getElementById('menuBtn');
      const list  = document.getElementById('menuList');
      const mTheme  = document.getElementById('menuTheme');
      const mPw     = document.getElementById('menuPw');
      const mLogout = document.getElementById('menuLogout');

      function openMenu(){ if (list){ list.style.display='block'; btn.setAttribute('aria-expanded','true'); } }
      function closeMenu(){ if (list){ list.style.display='none'; btn.setAttribute('aria-expanded','false'); } }
      function toggleMenu(e){ e.stopPropagation(); if (!list) return;
        list.style.display = (list.style.display === 'block') ? 'none' : 'block';
        btn.setAttribute('aria-expanded', list.style.display === 'block' ? 'true' : 'false');
      }

      if (btn) btn.addEventListener('click', toggleMenu);
      // Close when clicking outside
      document.addEventListener('click', (ev)=> {
        if (!list || !btn) return;
        const within = btn.contains(ev.target) || list.contains(ev.target);
        if (!within) closeMenu();
      });

      // Theme toggle now lives in menu
      if (mTheme) mTheme.addEventListener('click', ()=> {
        const next = document.body.classList.contains('dark') ? 'light' : 'dark';
        applyTheme(next);
        // Update menu label
        mTheme.textContent = 'Theme: ' + (next === 'dark' ? 'Dark' : 'Light');
        closeMenu();
      });

      // Open Change Password modal
      if (mPw) mPw.addEventListener('click', ()=> {
        const btnOpen = document.getElementById('pwbtn');
        // For backward compatibility, call the modal opener directly:
        const modal = document.getElementById('pwModal');
        if (modal){
          // emulate previous openModal() logic
          const err = document.getElementById('pw_error');
          const inpCur = document.getElementById('pw_current');
          const inpNew = document.getElementById('pw_new');
          const inpConf= document.getElementById('pw_confirm');
          if (err) err.textContent = '';
          if (inpCur) inpCur.value = '';
          if (inpNew) inpNew.value = '';
          if (inpConf) inpConf.value= '';
          modal.style.display = 'flex';
          setTimeout(()=> inpCur && inpCur.focus(), 0);
        }
        closeMenu();
      });

      // Logout
      if (mLogout) mLogout.addEventListener('click', async ()=> {
        try {
          const r = await fetch('/logout', { method: 'POST', headers: { 'X-CSRF-Token': CSRF } });
          if (r.ok) location.reload(); else showToast('Logout failed', 'error');
        } catch(e){ console.error(e); showToast('Logout error', 'error'); }
        closeMenu();
      });

      // Initialize theme label once
      if (mTheme){
        mTheme.textContent = 'Theme: ' + (document.body.classList.contains('dark') ? 'Dark' : 'Light');
      }
    })();


    // ---- Change password modal ----
    (function () {
      const modal = document.getElementById('pwModal');
      const btnCancel = document.getElementById('pw_cancel');
      const btnSave = document.getElementById('pw_save');
      const inpCur = document.getElementById('pw_current');
      const inpNew = document.getElementById('pw_new');
      const inpConf = document.getElementById('pw_confirm');
      const err = document.getElementById('pw_error');

      function openModal() {
        if (!modal) return;
        err.textContent = '';
        inpCur.value = '';
        inpNew.value = '';
        inpConf.value = '';
        modal.style.display = 'flex';
        setTimeout(() => inpCur.focus(), 0);
      }
      function closeModal() {
        if (!modal) return;
        modal.style.display = 'none';
      }

      if (btnCancel) btnCancel.addEventListener('click', closeModal);

      if (btnSave) btnSave.addEventListener('click', async () => {
        err.textContent = '';
        const current = inpCur.value || '';
        const next = inpNew.value || '';
        const confirmPw = inpConf.value || '';
        if (!current || !next || !confirmPw) {
          err.textContent = 'Please fill in all fields.';
          return;
        }
        if (next !== confirmPw) {
          err.textContent = 'New passwords do not match.';
          return;
        }
        try {
          const r = await fetch('/api/change_password', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': CSRF },
            body: JSON.stringify({ current, new: next, confirm: confirmPw })
          });
          const j = await r.json().catch(() => ({}));
          if (!r.ok || !j.ok) {
            err.textContent = j.error || r.statusText || 'Failed to change password.';
            showToast('Failed to change password', 'error');
          } else {
            closeModal();
            showToast('Password updated', 'ok');
          }
        } catch (e) {
          console.error(e);
          err.textContent = 'Unexpected error.';
        }
      });

      // Close modal when clicking the overlay
      if (modal) {
        modal.addEventListener('click', (ev) => {
          if (ev.target === modal) closeModal();
        });
      }
    })();

    document.getElementById('hddovr').addEventListener('input', ()=> setDirty('ovr', true));
    document.getElementById('ssdovr').addEventListener('input', ()=> setDirty('ovr', true));
    const autoMinEl = document.getElementById('auto_min');
    const autoHystEl = document.getElementById('auto_hyst');
    if (autoMinEl) autoMinEl.addEventListener('input', ()=> setDirty('ovr', true));
    if (autoHystEl) autoHystEl.addEventListener('input', ()=> setDirty('ovr', true));

    document.getElementById('savebtn').addEventListener('click', async () => {
      const h = parseInt(document.getElementById('hddovr').value, 10);
      const s = parseInt(document.getElementById('ssdovr').value, 10);
      try {
        await fetch('/api/settings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': CSRF },
          body: JSON.stringify({
            single_override_hdd_c: isNaN(h) ? undefined : h,
            single_override_ssd_c: isNaN(s) ? undefined : s,
            auto_apply_min_interval_s: (autoMinEl && !isNaN(parseInt(autoMinEl.value,10))) ? parseInt(autoMinEl.value,10) : undefined,
            auto_apply_hysteresis_duty: (autoHystEl && !isNaN(parseInt(autoHystEl.value,10))) ? parseInt(autoHystEl.value,10) : undefined
          })
        });
        setDirty('ovr', false);
        showToast('Overrides saved', 'ok');
        refresh();
      } catch (err) {
        showToast('Failed to save overrides', 'error');
        console.error(err);
      }
    });

    document.getElementById('savecurves').addEventListener('click', async () => {
      const ch_th = document.getElementById('curveH_th').querySelectorAll('input');
      const ch_pw = document.getElementById('curveH_pw').querySelectorAll('input');
      const cs_th = document.getElementById('curveS_th').querySelectorAll('input');
      const cs_pw = document.getElementById('curveS_pw').querySelectorAll('input');
      const HTH2 = Array.from(ch_th).map(i => parseInt(i.value||'0',10));
      const HPW2 = Array.from(ch_pw).map(i => parseInt(i.value||'0',10));
      const STH2 = Array.from(cs_th).map(i => parseInt(i.value||'0',10));
      const SPW2 = Array.from(cs_pw).map(i => parseInt(i.value||'0',10));
      try {
        await fetch('/api/curves', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': CSRF },
          body: JSON.stringify({ hdd_thresholds: HTH2, hdd_pwm: HPW2, ssd_thresholds: STH2, ssd_pwm: SPW2 })
        });
        setDirty('curves', false);
        showToast('Fan curves saved', 'ok');
        refresh();
      } catch (err) {
        showToast('Failed to save fan curves', 'error');
        console.error(err);
      }
    });

    document.getElementById('discardbtn').addEventListener('click', ()=> { setDirty('ovr', false); refresh(); });
    document.getElementById('discardcurves').addEventListener('click', ()=> { setDirty('curves', false); refresh(); });

    // Reset to defaults (overrides + fan curves)
    (function(){
      const btn = document.getElementById('resetDefaults');
      const modal = document.getElementById('resetModal');
      const cancelBtn = document.getElementById('reset_cancel');
      const confirmBtn = document.getElementById('reset_confirm');
      const err = document.getElementById('reset_error');

      if (!btn || !modal) return;

      function openModal(){
        if (err) err.textContent = '';
        modal.style.display = 'flex';
      }
      function closeModal(){ modal.style.display = 'none'; }

      btn.addEventListener('click', openModal);
      if (cancelBtn) cancelBtn.addEventListener('click', closeModal);
      if (modal) modal.addEventListener('click', (ev)=>{ if (ev.target === modal) closeModal(); });

      if (confirmBtn) confirmBtn.addEventListener('click', async ()=>{
        if (err) err.textContent = '';
        try {
          const r = await fetch('/api/reset_defaults', { method: 'POST', headers: { 'X-CSRF-Token': CSRF } });
          const j = await r.json().catch(()=>({}));
          if (!r.ok || !j.ok) {
            if (err) err.textContent = j.error || 'Failed to reset.';
            showToast('Failed to reset defaults', 'error');
            return;
          }
          setDirty('ovr', false);
          setDirty('curves', false);
          closeModal();
          showToast('Restored defaults', 'ok');
          refresh();
        } catch (e) {
          console.error(e);
          if (err) err.textContent = 'Unexpected error while resetting.';
          showToast('Failed to reset defaults', 'error');
        }
      });
    })();

    // Theme toggle (light/dark)
    const THEME_KEY = 'fanbridgeTheme';
    function applyTheme(t){
      const dark = (t === 'dark');
      document.body.classList.toggle('dark', dark);
      try { localStorage.setItem(THEME_KEY, dark ? 'dark' : 'light'); } catch(e) {}
      // Update menu item label if present
      const mTheme = document.getElementById('menuTheme');
      if (mTheme) mTheme.textContent = 'Theme: ' + (dark ? 'Dark' : 'Light');
    }
    (function(){
      let pref = 'light';
      try {
        pref = localStorage.getItem(THEME_KEY) ||
          (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
      } catch(e) {}
      applyTheme(pref);
      // Update menu item label if present
      const mTheme = document.getElementById('menuTheme');
      if (mTheme) mTheme.textContent = 'Theme: ' + (pref === 'dark' ? 'Dark' : 'Light');
    })();
  </script>
  <script>
    // Logs download helper
    (function(){
      const btn = document.getElementById('log_dl_btn');
      const fmtSel = document.getElementById('log_dl_fmt');
      const fromEl = document.getElementById('log_from');
      const toEl = document.getElementById('log_to');
      const clrBtn = document.getElementById('log_clear_btn');
      if (!btn || !fmtSel) return;
      function currentMin(){
        if (logFilters.has('DEBUG')) return 'DEBUG';
        if (logFilters.has('INFO')) return 'INFO';
        if (logFilters.has('WARNING')) return 'WARNING';
        return 'ERROR';
      }
      function toEpochSeconds(el){
        if (!el || !el.value) return null;
        try { return Math.floor(new Date(el.value).getTime()/1000); } catch(e){ return null; }
      }
      btn.addEventListener('click', ()=>{
        const fmt = fmtSel.value || 'text';
        const min = currentMin();
        const fromTs = toEpochSeconds(fromEl);
        const toTs = toEpochSeconds(toEl);
        const parts = [
          `format=${encodeURIComponent(fmt)}`,
          `min_level=${encodeURIComponent(min)}`,
        ];
        if (fromTs) parts.push(`from_ts=${fromTs}`);
        if (toTs) parts.push(`to_ts=${toTs}`);
        const url = `/api/logs/download?${parts.join('&')}`;
        try { window.open(url, '_blank'); } catch(e){ window.location.href = url; }
      });
      if (clrBtn) clrBtn.addEventListener('click', async ()=>{
        try{
          await fetch('/api/logs/clear', { method:'POST', headers: { 'X-CSRF-Token': CSRF } });
          const box = document.getElementById('logbox'); if (box) box.innerHTML='';
          logsSince = 0;
          showToast('Logs cleared', 'ok');
        }catch(e){ showToast('Failed to clear logs', 'error'); }
      });
    })();
  </script>
  <script>
    // Toggle handler for auto-apply
    (function(){
      const aa = document.getElementById('auto_apply');
      if (!aa) return;
      aa.addEventListener('change', async () => {
        try {
          await fetch('/api/auto_apply', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': CSRF },
            body: JSON.stringify({ enabled: !!aa.checked })
          });
        } catch (e) { console.error(e); }
      });
    })();
  </script>
  <script>
    // Logs controls
    (function(){
      const box = document.getElementById('logbox');
      const sel = document.getElementById('log_level');
      document.querySelectorAll('.logfilter').forEach(cb=>{
        cb.addEventListener('change', ()=>{
          const v = cb.value.toUpperCase();
          if (cb.checked) logFilters.add(v); else logFilters.delete(v);
          if (box) box.innerHTML = '';
          logsSince = 0;
          logsTick();
        });
      });
      if (sel) sel.addEventListener('change', async ()=>{
        try{
          await fetch('/api/log_level', {
            method:'POST',
            headers: { 'Content-Type':'application/json', 'X-CSRF-Token': CSRF },
            body: JSON.stringify({ level: sel.value })
          });
        }catch(e){ console.error(e); }
      });
    })();
  </script>
  <script>
    // RP repo controls and flash
    (function(){
      const saveBtn = document.getElementById('rpSaveRepo');
      const urlEl = document.getElementById('rpRepoUrl');
      const flashBtn = document.getElementById('rpFlashLatest');
      const warn = document.getElementById('rpWarn');
      const confirmModal = document.getElementById('rpFlashConfirm');
      const confirmBtn = document.getElementById('rpFlashConfirmBtn');
      const cancelBtn = document.getElementById('rpFlashCancel');
      const progModal = document.getElementById('rpFlashProgress');
      const progBox = document.getElementById('rpProgLog');
      const progClose = document.getElementById('rpProgClose');

      function openConfirm(){ if (confirmModal) { confirmModal.style.display = 'flex'; } }
      function closeConfirm(){ if (confirmModal) { confirmModal.style.display = 'none'; } }
      function openProgress(){ if (progModal) { progModal.style.display = 'flex'; } }
      function closeProgress(){ if (progModal) { progModal.style.display = 'none'; } }
      function progAppend(text, type){
        if (!progBox) return;
        const line = document.createElement('div');
        const ts = new Date().toLocaleTimeString();
        line.className = 'line ' + (type || '');
        line.textContent = `[${ts}] ${text}`;
        progBox.appendChild(line);
        progBox.scrollTop = progBox.scrollHeight;
      }
      function bindClose(){ if (progClose){ progClose.disabled = false; progClose.addEventListener('click', ()=>{ closeProgress(); refreshRp(); }); } }

      async function saveRepo(){
        if (!urlEl || !urlEl.value) return;
        try{
          const r = await fetch('/api/rp/repo', { method:'POST', headers: { 'Content-Type':'application/json', 'X-CSRF-Token': CSRF }, body: JSON.stringify({ repo_url: urlEl.value }) });
          const j = await r.json().catch(()=>({}));
          if (!r.ok || !j.ok){ showToast('Failed to save repo URL', 'error'); return; }
          showToast('Saved repo URL', 'ok');
          refreshRp();
        }catch(e){ showToast('Failed to save repo URL', 'error'); }
      }
      async function flashLatest(){
        if (warn){ warn.style.display='none'; warn.textContent=''; }
        openConfirm();
      }
      async function doFlash(){
        closeConfirm();
        openProgress();
        if (progBox) progBox.innerHTML = '';
        progAppend('Starting firmware update…');
        try{
          flashBtn.disabled = true; flashBtn.textContent = 'Flashing…';
          const r = await fetch('/api/rp/flash', { method:'POST', headers: { 'Content-Type':'application/json', 'X-CSRF-Token': CSRF }, body: JSON.stringify({}) });
          const j = await r.json().catch(()=>({}));
          const steps = (j && Array.isArray(j.progress)) ? j.progress : [];
          for (const s of steps){
            const ok = (s.ok === undefined) ? '' : (s.ok ? 'ok' : 'error');
            const extra = (()=>{
              const keys = Object.keys(s).filter(k=>!['ts','msg','ok'].includes(k));
              if (!keys.length) return '';
              return ' ' + keys.map(k=>`${k}=${s[k]}`).join(' ');
            })();
            progAppend(`${s.msg}${extra}`, ok);
          }
          if (!r.ok || !j.ok){
            const status = `${r.status||''} ${r.statusText||''}`.trim();
            const msg = j.error || (status ? `Flash failed (${status})` : 'Flash failed');
            progAppend('ERROR: ' + msg, 'error');
            showToast(msg, 'error');
          } else {
            progAppend('Firmware update complete. You may now close this window.', 'ok');
            showToast('Flashed firmware ' + (j.version || ''), 'ok');
          }
        }catch(e){ progAppend('Unexpected error during flash', 'error'); showToast('Flash failed', 'error'); }
        finally{ flashBtn.disabled = false; flashBtn.textContent = 'Install latest'; bindClose(); setTimeout(refreshRp, 1500); }
      }
      if (saveBtn) saveBtn.addEventListener('click', saveRepo);
      if (urlEl) urlEl.addEventListener('keydown', (ev)=>{ if (ev.key === 'Enter') saveRepo(); });
      // Flash coming soon: button disabled; no action bound
      if (flashBtn) flashBtn.addEventListener('click', flashLatest);
      if (confirmBtn) confirmBtn.addEventListener('click', doFlash);
      if (cancelBtn) cancelBtn.addEventListener('click', closeConfirm);
      if (confirmModal) confirmModal.addEventListener('click', (ev)=>{ if (ev.target === confirmModal) closeConfirm(); });
    })();
  </script>
  <script>
  // ---- Serial helpers (UI -> API) ----
  function serialTs(){ const d=new Date(); return d.toLocaleTimeString(); }
  function scAppend(type, text){
    const host = document.getElementById('serialConsole');
    if (!host) return;
    const line = document.createElement('div');
    line.innerHTML = `<span class="ts">[${serialTs()}]</span> <span class="${type}">${text.replace(/&/g,'&amp;').replace(/</g,'&lt;')}</span>`;
    host.appendChild(line);
    host.scrollTop = host.scrollHeight;
  }

  async function apiSerialSend(line){
    try {
      const r = await fetch('/api/serial/send', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': CSRF },
        body: JSON.stringify({ line: String(line||'') })
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok || j.ok === false) throw new Error(j.error || r.statusText || 'send failed');
      if (j.echo) scAppend('in',  j.echo);
      if (j.reply) scAppend('out', j.reply);
      showToast('Command sent', 'ok');
    } catch(e){ scAppend('err', 'SEND ERROR: '+e.message); showToast('Serial send failed', 'error'); }
  }

  async function apiSerialPwm(val){
    try {
      const r = await fetch('/api/serial/pwm', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': CSRF },
        body: JSON.stringify({ value: Number(val)||0 })
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok || j.ok === false) throw new Error(j.error || r.statusText || 'pwm failed');
      if (j.echo) scAppend('in',  j.echo);
      if (j.reply) scAppend('out', j.reply);
      showToast('PWM updated', 'ok');
    } catch(e){ scAppend('err', 'PWM ERROR: '+e.message); showToast('PWM update failed', 'error'); }
  }

  // Wire up Serial tab controls once DOM is ready
  (function(){
    const btnPing = document.getElementById('btnPing');
    const btnTest = document.getElementById('btnTest');
    const btnVer  = document.getElementById('btnVer');
    const btnStat = document.getElementById('btnStat');
    const btnSend = document.getElementById('btnSendLine');
    const inputLn = document.getElementById('serialLine');
    const rng     = document.getElementById('pwmRange');
    const lbl     = document.getElementById('pwmVal');
    const btnPwm  = document.getElementById('btnPwmSend');
    const btnZero = document.getElementById('btnPwmZero');
    const pill    = document.getElementById('serialStatus');

    if (rng && lbl){
      const upd=()=>{ lbl.textContent= String(rng.value) + '%'; };
      rng.addEventListener('input', upd); upd();
    }

    if (btnPing) btnPing.addEventListener('click', ()=> apiSerialSend('ping'));
    if (btnTest) btnTest.addEventListener('click', ()=> apiSerialSend('test'));
    if (btnVer)  btnVer .addEventListener('click', ()=> apiSerialSend('version'));
    if (btnStat) btnStat.addEventListener('click', ()=> apiSerialSend('status'));

    if (btnSend) btnSend.addEventListener('click', ()=>{
      const v = (inputLn && inputLn.value) ? inputLn.value.trim() : '';
      if (!v) return;
      apiSerialSend(v);
    });
    if (inputLn) inputLn.addEventListener('keydown', (e)=>{
      if (e.key==='Enter') { e.preventDefault(); const v=inputLn.value.trim(); if (v) apiSerialSend(v); }
    });

    if (btnPwm && rng) btnPwm.addEventListener('click', ()=> apiSerialPwm(rng.value));
    if (btnZero){
      btnZero.addEventListener('click', ()=>{ if (rng){ rng.value=0; lbl && (lbl.textContent='0%'); } apiSerialPwm(0); });
    }

    // Keep the Serial tab header pill in sync with global refreshSerial()
    const _oldRefreshSerial = refreshSerial;
    refreshSerial = async function(){
      // 1) Quick tools probe for the Serial tab pill
      try {
        // Use a short timeout so the pill never "hangs"
        const ctrl = new AbortController();
        const timer = setTimeout(() => ctrl.abort(), 2500);
        const r = await fetch('/api/serial/tools', { cache: 'no-store', signal: ctrl.signal });
        clearTimeout(timer);
        const t = await r.json();
        if (t && t.ok) {
          if (pill){
            const pc = t.checks || {};
            const pingOk = pc.ping && pc.ping.ok;
            const ms = pingOk && typeof pc.ping.ms === 'number' ? ` (${pc.ping.ms} ms)` : '';
            pill.textContent = `connected${ms}`;
            pill.title = (t.port || t.preferred || '') + ms;
            pill.classList.remove('warn','error');
            pill.classList.add('ok');
          }
        } else {
          if (pill){
            pill.textContent = 'not opened';
            pill.title = (t && t.port) ? String(t.port) : 'no port';
            pill.classList.add('warn');
            pill.classList.remove('error','ok');
          }
        }
      } catch(e){
        if (pill){
          pill.textContent = 'error';
          pill.title = 'serial tools status error';
          pill.classList.add('error');
          pill.classList.remove('warn');
        }
      }

      // 2) Also call the original logic to update the header serial pill
      try { if (typeof _oldRefreshSerial === 'function') await _oldRefreshSerial(); } catch(_){}
    }
  })();
  </script>
  <div id="toastHost" class="toast-container" aria-live="polite" aria-atomic="true"></div>
</body>
</html>
